/home/s22100141/Capston2/cJSON_ijon/cJSON.h:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |#ifndef cJSON__h
   24|       |#define cJSON__h
   25|       |
   26|       |#ifdef __cplusplus
   27|       |extern "C"
   28|       |{
   29|       |#endif
   30|       |
   31|       |#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))
   32|       |#define __WINDOWS__
   33|       |#endif
   34|       |
   35|       |#ifdef __WINDOWS__
   36|       |
   37|       |/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:
   38|       |
   39|       |CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
   40|       |CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
   41|       |CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol
   42|       |
   43|       |For *nix builds that support visibility attribute, you can define similar behavior by
   44|       |
   45|       |setting default visibility to hidden by adding
   46|       |-fvisibility=hidden (for gcc)
   47|       |or
   48|       |-xldscope=hidden (for sun cc)
   49|       |to CFLAGS
   50|       |
   51|       |then using the CJSON_API_VISIBILITY flag to "export" the same symbols the way CJSON_EXPORT_SYMBOLS does
   52|       |
   53|       |*/
   54|       |
   55|       |#define CJSON_CDECL __cdecl
   56|       |#define CJSON_STDCALL __stdcall
   57|       |
   58|       |/* export symbols by default, this is necessary for copy pasting the C and header file */
   59|       |#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)
   60|       |#define CJSON_EXPORT_SYMBOLS
   61|       |#endif
   62|       |
   63|       |#if defined(CJSON_HIDE_SYMBOLS)
   64|       |#define CJSON_PUBLIC(type)   type CJSON_STDCALL
   65|       |#elif defined(CJSON_EXPORT_SYMBOLS)
   66|       |#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL
   67|       |#elif defined(CJSON_IMPORT_SYMBOLS)
   68|       |#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL
   69|       |#endif
   70|       |#else /* !__WINDOWS__ */
   71|       |#define CJSON_CDECL
   72|       |#define CJSON_STDCALL
   73|       |
   74|       |#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)
   75|       |#define CJSON_PUBLIC(type)   __attribute__((visibility("default"))) type
   76|       |#else
   77|       |#define CJSON_PUBLIC(type) type
   78|       |#endif
   79|       |#endif
   80|       |
   81|       |/* project version */
   82|      0|#define CJSON_VERSION_MAJOR 1
   83|      0|#define CJSON_VERSION_MINOR 7
   84|      0|#define CJSON_VERSION_PATCH 17
   85|       |
   86|       |#include <stddef.h>
   87|       |
   88|       |/* cJSON Types: */
   89|      0|#define cJSON_Invalid (0)
   90|    948|#define cJSON_False  (1 << 0)
   91|    292|#define cJSON_True   (1 << 1)
   92|  1.69k|#define cJSON_NULL   (1 << 2)
   93|  6.82k|#define cJSON_Number (1 << 3)
   94|  38.2k|#define cJSON_String (1 << 4)
   95|  13.6k|#define cJSON_Array  (1 << 5)
   96|  10.6k|#define cJSON_Object (1 << 6)
   97|      0|#define cJSON_Raw    (1 << 7) /* raw json */
   98|       |
   99|  90.7k|#define cJSON_IsReference 256
  100|  45.3k|#define cJSON_StringIsConst 512
  101|       |
  102|       |/* The cJSON structure: */
  103|       |typedef struct cJSON
  104|       |{
  105|       |    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
  106|       |    struct cJSON *next;
  107|       |    struct cJSON *prev;
  108|       |    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
  109|       |    struct cJSON *child;
  110|       |
  111|       |    /* The type of the item, as above. */
  112|       |    int type;
  113|       |
  114|       |    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
  115|       |    char *valuestring;
  116|       |    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
  117|       |    int valueint;
  118|       |    /* The item's number, if type==cJSON_Number */
  119|       |    double valuedouble;
  120|       |
  121|       |    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
  122|       |    char *string;
  123|       |} cJSON;
  124|       |
  125|       |typedef struct cJSON_Hooks
  126|       |{
  127|       |      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
  128|       |      void *(CJSON_CDECL *malloc_fn)(size_t sz);
  129|       |      void (CJSON_CDECL *free_fn)(void *ptr);
  130|       |} cJSON_Hooks;
  131|       |
  132|       |typedef int cJSON_bool;
  133|       |
  134|       |/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.
  135|       | * This is to prevent stack overflows. */
  136|       |#ifndef CJSON_NESTING_LIMIT
  137|  25.9k|#define CJSON_NESTING_LIMIT 1000
  138|       |#endif
  139|       |
  140|       |/* returns the version of cJSON as a string */
  141|       |CJSON_PUBLIC(const char*) cJSON_Version(void);
  142|       |
  143|       |/* Supply malloc, realloc and free functions to cJSON */
  144|       |CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);
  145|       |
  146|       |/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
  147|       |/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
  148|       |CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
  149|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);
  150|       |/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
  151|       |/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
  152|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
  153|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);
  154|       |
  155|       |/* Render a cJSON entity to text for transfer/storage. */
  156|       |CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
  157|       |/* Render a cJSON entity to text for transfer/storage without any formatting. */
  158|       |CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
  159|       |/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
  160|       |CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
  161|       |/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
  162|       |/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
  163|       |CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
  164|       |/* Delete a cJSON entity and all subentities. */
  165|       |CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);
  166|       |
  167|       |/* Returns the number of items in an array (or object). */
  168|       |CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
  169|       |/* Retrieve item number "index" from array "array". Returns NULL if unsuccessful. */
  170|       |CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
  171|       |/* Get item "string" from object. Case insensitive. */
  172|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
  173|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
  174|       |CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
  175|       |/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
  176|       |CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);
  177|       |
  178|       |/* Check item type and return its value */
  179|       |CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);
  180|       |CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);
  181|       |
  182|       |/* These functions check the type of an item */
  183|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
  184|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
  185|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
  186|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
  187|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
  188|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
  189|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
  190|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
  191|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
  192|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);
  193|       |
  194|       |/* These calls create a cJSON item of the appropriate type. */
  195|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
  196|       |CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
  197|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
  198|       |CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
  199|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
  200|       |CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
  201|       |/* raw json */
  202|       |CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
  203|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
  204|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);
  205|       |
  206|       |/* Create a string where valuestring references a string so
  207|       | * it will not be freed by cJSON_Delete */
  208|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
  209|       |/* Create an object/array that only references it's elements so
  210|       | * they will not be freed by cJSON_Delete */
  211|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
  212|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);
  213|       |
  214|       |/* These utilities create an Array of count items.
  215|       | * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/
  216|       |CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
  217|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
  218|       |CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
  219|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);
  220|       |
  221|       |/* Append item to the specified array/object. */
  222|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);
  223|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
  224|       |/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
  225|       | * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
  226|       | * writing to `item->string` */
  227|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
  228|       |/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
  229|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
  230|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);
  231|       |
  232|       |/* Remove/Detach items from Arrays/Objects. */
  233|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
  234|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
  235|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
  236|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
  237|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
  238|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
  239|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
  240|       |
  241|       |/* Update array items. */
  242|       |CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
  243|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
  244|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
  245|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
  246|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);
  247|       |
  248|       |/* Duplicate a cJSON item */
  249|       |CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
  250|       |/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
  251|       | * need to be released. With recurse!=0, it will duplicate any children connected to the item.
  252|       | * The item->next and ->prev pointers are always zero on return from Duplicate. */
  253|       |/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
  254|       | * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
  255|       |CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);
  256|       |
  257|       |/* Minify a strings, remove blank characters(such as ' ', '\t', '\r', '\n') from strings.
  258|       | * The input pointer json cannot point to a read-only address area, such as a string constant, 
  259|       | * but should point to a readable and writable address area. */
  260|       |CJSON_PUBLIC(void) cJSON_Minify(char *json);
  261|       |
  262|       |/* Helper functions for creating and adding items to an object at the same time.
  263|       | * They return the added item or NULL on failure. */
  264|       |CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
  265|       |CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
  266|       |CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
  267|       |CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
  268|       |CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
  269|       |CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
  270|       |CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
  271|       |CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
  272|       |CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);
  273|       |
  274|       |/* When assigning an integer value, it needs to be propagated to valuedouble too. */
  275|       |#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
  276|       |/* helper for the cJSON_SetNumberValue macro */
  277|       |CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
  278|       |#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
  279|       |/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */
  280|       |CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);
  281|       |
  282|       |/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/
  283|       |#define cJSON_SetBoolValue(object, boolValue) ( \
  284|       |    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \
  285|       |    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \
  286|       |    cJSON_Invalid\
  287|       |)
  288|       |
  289|       |/* Macro for iterating over an array or object */
  290|      0|#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
  291|       |
  292|       |/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
  293|       |CJSON_PUBLIC(void *) cJSON_malloc(size_t size);
  294|       |CJSON_PUBLIC(void) cJSON_free(void *object);
  295|       |
  296|       |#ifdef __cplusplus
  297|       |}
  298|       |#endif
  299|       |
  300|       |#endif

/home/s22100141/Capston2/cJSON_ijon/cJSON_origin.c:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |/* cJSON */
   24|       |/* JSON parser in C. */
   25|       |
   26|       |/* disable warnings about old C89 functions in MSVC */
   27|       |#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
   28|       |#define _CRT_SECURE_NO_DEPRECATE
   29|       |#endif
   30|       |
   31|       |#ifdef __GNUC__
   32|       |#pragma GCC visibility push(default)
   33|       |#endif
   34|       |#if defined(_MSC_VER)
   35|       |#pragma warning (push)
   36|       |/* disable warning about single line comments in system headers */
   37|       |#pragma warning (disable : 4001)
   38|       |#endif
   39|       |
   40|       |#include <string.h>
   41|       |#include <stdio.h>
   42|       |#include <math.h>
   43|       |#include <stdlib.h>
   44|       |#include <limits.h>
   45|       |#include <ctype.h>
   46|       |#include <float.h>
   47|       |
   48|       |#ifdef ENABLE_LOCALES
   49|       |#include <locale.h>
   50|       |#endif
   51|       |
   52|       |#if defined(_MSC_VER)
   53|       |#pragma warning (pop)
   54|       |#endif
   55|       |#ifdef __GNUC__
   56|       |#pragma GCC visibility pop
   57|       |#endif
   58|       |
   59|       |#include "cJSON.h"
   60|       |
   61|       |/* define our own boolean type */
   62|       |#ifdef true
   63|       |#undef true
   64|       |#endif
   65|  82.8k|#define true ((cJSON_bool)1)
   66|       |
   67|       |#ifdef false
   68|       |#undef false
   69|       |#endif
   70|  11.7k|#define false ((cJSON_bool)0)
   71|       |
   72|       |/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */
   73|       |#ifndef isinf
   74|       |#define isinf(d) (isnan((d - d)) && !isnan(d))
   75|       |#endif
   76|       |#ifndef isnan
   77|       |#define isnan(d) (d != d)
   78|       |#endif
   79|       |
   80|       |#ifndef NAN
   81|       |#ifdef _WIN32
   82|       |#define NAN sqrt(-1.0)
   83|       |#else
   84|       |#define NAN 0.0/0.0
   85|       |#endif
   86|       |#endif
   87|       |
   88|       |typedef struct {
   89|       |    const unsigned char *json;
   90|       |    size_t position;
   91|       |} error;
   92|       |static error global_error = { NULL, 0 };
   93|       |
   94|       |CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
   95|      0|{
   96|      0|    return (const char*) (global_error.json + global_error.position);
   97|      0|}
   98|       |
   99|       |CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)
  100|      0|{
  101|      0|    if (!cJSON_IsString(item))
  102|      0|    {
  103|      0|        return NULL;
  104|      0|    }
  105|       |
  106|      0|    return item->valuestring;
  107|      0|}
  108|       |
  109|       |CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)
  110|      0|{
  111|      0|    if (!cJSON_IsNumber(item))
  112|      0|    {
  113|      0|        return (double) NAN;
  114|      0|    }
  115|       |
  116|      0|    return item->valuedouble;
  117|      0|}
  118|       |
  119|       |/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
  120|       |#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 17)
  121|       |    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
  122|       |#endif
  123|       |
  124|       |CJSON_PUBLIC(const char*) cJSON_Version(void)
  125|      0|{
  126|      0|    static char version[15];
  127|      0|    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
  128|       |
  129|      0|    return version;
  130|      0|}
  131|       |
  132|       |/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
  133|       |static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
  134|      0|{
  135|      0|    if ((string1 == NULL) || (string2 == NULL))
  136|      0|    {
  137|      0|        return 1;
  138|      0|    }
  139|       |
  140|      0|    if (string1 == string2)
  141|      0|    {
  142|      0|        return 0;
  143|      0|    }
  144|       |
  145|      0|    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
  146|      0|    {
  147|      0|        if (*string1 == '\0')
  148|      0|        {
  149|      0|            return 0;
  150|      0|        }
  151|      0|    }
  152|       |
  153|      0|    return tolower(*string1) - tolower(*string2);
  154|      0|}
  155|       |
  156|       |typedef struct internal_hooks
  157|       |{
  158|       |    void *(CJSON_CDECL *allocate)(size_t size);
  159|       |    void (CJSON_CDECL *deallocate)(void *pointer);
  160|       |    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
  161|       |} internal_hooks;
  162|       |
  163|       |#if defined(_MSC_VER)
  164|       |/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
  165|       |static void * CJSON_CDECL internal_malloc(size_t size)
  166|       |{
  167|       |    return malloc(size);
  168|       |}
  169|       |static void CJSON_CDECL internal_free(void *pointer)
  170|       |{
  171|       |    free(pointer);
  172|       |}
  173|       |static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
  174|       |{
  175|       |    return realloc(pointer, size);
  176|       |}
  177|       |#else
  178|       |#define internal_malloc malloc
  179|       |#define internal_free free
  180|       |#define internal_realloc realloc
  181|       |#endif
  182|       |
  183|       |/* strlen of character literals resolved at compile time */
  184|      0|#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
  185|       |
  186|       |static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
  187|       |
  188|       |static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
  189|      0|{
  190|      0|    size_t length = 0;
  191|      0|    unsigned char *copy = NULL;
  192|       |
  193|      0|    if (string == NULL)
  194|      0|    {
  195|      0|        return NULL;
  196|      0|    }
  197|       |
  198|      0|    length = strlen((const char*)string) + sizeof("");
  199|      0|    copy = (unsigned char*)hooks->allocate(length);
  200|      0|    if (copy == NULL)
  201|      0|    {
  202|      0|        return NULL;
  203|      0|    }
  204|      0|    memcpy(copy, string, length);
  205|       |
  206|      0|    return copy;
  207|      0|}
  208|       |
  209|       |CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
  210|      0|{
  211|      0|    if (hooks == NULL)
  212|      0|    {
  213|       |        /* Reset hooks */
  214|      0|        global_hooks.allocate = malloc;
  215|      0|        global_hooks.deallocate = free;
  216|      0|        global_hooks.reallocate = realloc;
  217|      0|        return;
  218|      0|    }
  219|       |
  220|      0|    global_hooks.allocate = malloc;
  221|      0|    if (hooks->malloc_fn != NULL)
  222|      0|    {
  223|      0|        global_hooks.allocate = hooks->malloc_fn;
  224|      0|    }
  225|       |
  226|      0|    global_hooks.deallocate = free;
  227|      0|    if (hooks->free_fn != NULL)
  228|      0|    {
  229|      0|        global_hooks.deallocate = hooks->free_fn;
  230|      0|    }
  231|       |
  232|       |    /* use realloc only if both free and malloc are used */
  233|      0|    global_hooks.reallocate = NULL;
  234|      0|    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
  235|      0|    {
  236|      0|        global_hooks.reallocate = realloc;
  237|      0|    }
  238|      0|}
  239|       |
  240|       |/* Internal constructor. */
  241|       |static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
  242|  45.3k|{
  243|  45.3k|    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
  244|  45.3k|    if (node)
  245|  45.3k|    {
  246|  45.3k|        memset(node, '\0', sizeof(cJSON));
  247|  45.3k|    }
  248|       |
  249|  45.3k|    return node;
  250|  45.3k|}
  251|       |
  252|       |/* Delete a cJSON structure. */
  253|       |CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
  254|  22.6k|{
  255|  22.6k|    cJSON *next = NULL;
  256|  68.0k|    while (item != NULL)
  257|  45.3k|    {
  258|  45.3k|        next = item->next;
  259|  45.3k|        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
  260|  10.4k|        {
  261|  10.4k|            cJSON_Delete(item->child);
  262|  10.4k|        }
  263|  45.3k|        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
  264|  13.1k|        {
  265|  13.1k|            global_hooks.deallocate(item->valuestring);
  266|  13.1k|        }
  267|  45.3k|        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
  268|  17.3k|        {
  269|  17.3k|            global_hooks.deallocate(item->string);
  270|  17.3k|        }
  271|  45.3k|        global_hooks.deallocate(item);
  272|  45.3k|        item = next;
  273|  45.3k|    }
  274|  22.6k|}
  275|       |
  276|       |/* get the decimal point character of the current locale */
  277|       |static unsigned char get_decimal_point(void)
  278|  6.83k|{
  279|       |#ifdef ENABLE_LOCALES
  280|       |    struct lconv *lconv = localeconv();
  281|       |    return (unsigned char) lconv->decimal_point[0];
  282|       |#else
  283|  6.83k|    return '.';
  284|  6.83k|#endif
  285|  6.83k|}
  286|       |
  287|       |typedef struct
  288|       |{
  289|       |    const unsigned char *content;
  290|       |    size_t length;
  291|       |    size_t offset;
  292|       |    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
  293|       |    internal_hooks hooks;
  294|       |} parse_buffer;
  295|       |
  296|       |/* check if the given size is left to read in a given parse buffer (starting with 1) */
  297|   265k|#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
  298|       |/* check if the buffer can be accessed at the given index (starting with 0) */
  299|  1.07M|#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
  300|   232k|#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
  301|       |/* get a pointer to the buffer at the position */
  302|   823k|#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
  303|       |
  304|       |/* Parse the input text to generate a number, and populate the result into item. */
  305|       |static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
  306|  3.98k|{
  307|  3.98k|    double number = 0;
  308|  3.98k|    unsigned char *after_end = NULL;
  309|  3.98k|    unsigned char number_c_string[64];
  310|  3.98k|    unsigned char decimal_point = get_decimal_point();
  311|  3.98k|    size_t i = 0;
  312|       |
  313|  3.98k|    if ((input_buffer == NULL) || (input_buffer->content == NULL))
  314|      0|    {
  315|      0|        return false;
  316|      0|    }
  317|       |
  318|       |    /* copy the number into a temporary buffer and replace '.' with the decimal point
  319|       |     * of the current locale (for strtod)
  320|       |     * This also takes care of '\0' not necessarily being available for marking the end of the input */
  321|  13.6k|    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
  322|  13.6k|    {
  323|  13.6k|        switch (buffer_at_offset(input_buffer)[i])
  324|  13.6k|        {
  325|  3.37k|            case '0':
  326|  5.01k|            case '1':
  327|  5.95k|            case '2':
  328|  6.63k|            case '3':
  329|  6.99k|            case '4':
  330|  7.63k|            case '5':
  331|  7.99k|            case '6':
  332|  8.32k|            case '7':
  333|  8.49k|            case '8':
  334|  8.94k|            case '9':
  335|  8.94k|            case '+':
  336|  9.30k|            case '-':
  337|  9.30k|            case 'e':
  338|  9.45k|            case 'E':
  339|  9.45k|                number_c_string[i] = buffer_at_offset(input_buffer)[i];
  340|  9.45k|                break;
  341|       |
  342|    179|            case '.':
  343|    179|                number_c_string[i] = decimal_point;
  344|    179|                break;
  345|       |
  346|  3.98k|            default:
  347|  3.98k|                goto loop_end;
  348|  13.6k|        }
  349|  13.6k|    }
  350|  3.98k|loop_end:
  351|  3.98k|    number_c_string[i] = '\0';
  352|       |
  353|  3.98k|    number = strtod((const char*)number_c_string, (char**)&after_end);
  354|  3.98k|    if (number_c_string == after_end)
  355|      8|    {
  356|      8|        return false; /* parse_error */
  357|      8|    }
  358|       |
  359|  3.97k|    item->valuedouble = number;
  360|       |
  361|       |    /* use saturation in case of overflow */
  362|  3.97k|    if (number >= INT_MAX)
  363|    160|    {
  364|    160|        item->valueint = INT_MAX;
  365|    160|    }
  366|  3.81k|    else if (number <= (double)INT_MIN)
  367|     14|    {
  368|     14|        item->valueint = INT_MIN;
  369|     14|    }
  370|  3.80k|    else
  371|  3.80k|    {
  372|  3.80k|        item->valueint = (int)number;
  373|  3.80k|    }
  374|       |
  375|  3.97k|    item->type = cJSON_Number;
  376|       |
  377|  3.97k|    input_buffer->offset += (size_t)(after_end - number_c_string);
  378|  3.97k|    return true;
  379|  3.98k|}
  380|       |
  381|       |/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
  382|       |CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
  383|      0|{
  384|      0|    if (number >= INT_MAX)
  385|      0|    {
  386|      0|        object->valueint = INT_MAX;
  387|      0|    }
  388|      0|    else if (number <= (double)INT_MIN)
  389|      0|    {
  390|      0|        object->valueint = INT_MIN;
  391|      0|    }
  392|      0|    else
  393|      0|    {
  394|      0|        object->valueint = (int)number;
  395|      0|    }
  396|       |
  397|      0|    return object->valuedouble = number;
  398|      0|}
  399|       |
  400|       |CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)
  401|      0|{
  402|      0|    char *copy = NULL;
  403|       |    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */
  404|      0|    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))
  405|      0|    {
  406|      0|        return NULL;
  407|      0|    }
  408|       |    /* return NULL if the object is corrupted */
  409|      0|    if (object->valuestring == NULL)
  410|      0|    {
  411|      0|        return NULL;
  412|      0|    }
  413|      0|    if (strlen(valuestring) <= strlen(object->valuestring))
  414|      0|    {
  415|      0|        strcpy(object->valuestring, valuestring);
  416|      0|        return object->valuestring;
  417|      0|    }
  418|      0|    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
  419|      0|    if (copy == NULL)
  420|      0|    {
  421|      0|        return NULL;
  422|      0|    }
  423|      0|    if (object->valuestring != NULL)
  424|      0|    {
  425|      0|        cJSON_free(object->valuestring);
  426|      0|    }
  427|      0|    object->valuestring = copy;
  428|       |
  429|      0|    return copy;
  430|      0|}
  431|       |
  432|       |typedef struct
  433|       |{
  434|       |    unsigned char *buffer;
  435|       |    size_t length;
  436|       |    size_t offset;
  437|       |    size_t depth; /* current nesting depth (for formatted printing) */
  438|       |    cJSON_bool noalloc;
  439|       |    cJSON_bool format; /* is this print a formatted print */
  440|       |    internal_hooks hooks;
  441|       |} printbuffer;
  442|       |
  443|       |/* realloc printbuffer if necessary to have at least "needed" bytes more */
  444|       |static unsigned char* ensure(printbuffer * const p, size_t needed)
  445|  77.3k|{
  446|  77.3k|    unsigned char *newbuffer = NULL;
  447|  77.3k|    size_t newsize = 0;
  448|       |
  449|  77.3k|    if ((p == NULL) || (p->buffer == NULL))
  450|      0|    {
  451|      0|        return NULL;
  452|      0|    }
  453|       |
  454|  77.3k|    if ((p->length > 0) && (p->offset >= p->length))
  455|      0|    {
  456|       |        /* make sure that offset is valid */
  457|      0|        return NULL;
  458|      0|    }
  459|       |
  460|  77.3k|    if (needed > INT_MAX)
  461|      0|    {
  462|       |        /* sizes bigger than INT_MAX are currently not supported */
  463|      0|        return NULL;
  464|      0|    }
  465|       |
  466|  77.3k|    needed += p->offset + 1;
  467|  77.3k|    if (needed <= p->length)
  468|  74.7k|    {
  469|  74.7k|        return p->buffer + p->offset;
  470|  74.7k|    }
  471|       |
  472|  2.63k|    if (p->noalloc) {
  473|      0|        return NULL;
  474|      0|    }
  475|       |
  476|       |    /* calculate new buffer size */
  477|  2.63k|    if (needed > (INT_MAX / 2))
  478|      0|    {
  479|       |        /* overflow of int, use INT_MAX if possible */
  480|      0|        if (needed <= INT_MAX)
  481|      0|        {
  482|      0|            newsize = INT_MAX;
  483|      0|        }
  484|      0|        else
  485|      0|        {
  486|      0|            return NULL;
  487|      0|        }
  488|      0|    }
  489|  2.63k|    else
  490|  2.63k|    {
  491|  2.63k|        newsize = needed * 2;
  492|  2.63k|    }
  493|       |
  494|  2.63k|    if (p->hooks.reallocate != NULL)
  495|  2.63k|    {
  496|       |        /* reallocate with realloc if available */
  497|  2.63k|        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
  498|  2.63k|        if (newbuffer == NULL)
  499|      0|        {
  500|      0|            p->hooks.deallocate(p->buffer);
  501|      0|            p->length = 0;
  502|      0|            p->buffer = NULL;
  503|       |
  504|      0|            return NULL;
  505|      0|        }
  506|  2.63k|    }
  507|      0|    else
  508|      0|    {
  509|       |        /* otherwise reallocate manually */
  510|      0|        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
  511|      0|        if (!newbuffer)
  512|      0|        {
  513|      0|            p->hooks.deallocate(p->buffer);
  514|      0|            p->length = 0;
  515|      0|            p->buffer = NULL;
  516|       |
  517|      0|            return NULL;
  518|      0|        }
  519|       |
  520|      0|        memcpy(newbuffer, p->buffer, p->offset + 1);
  521|      0|        p->hooks.deallocate(p->buffer);
  522|      0|    }
  523|  2.63k|    p->length = newsize;
  524|  2.63k|    p->buffer = newbuffer;
  525|       |
  526|  2.63k|    return newbuffer + p->offset;
  527|  2.63k|}
  528|       |
  529|       |/* calculate the new length of the string in a printbuffer and update the offset */
  530|       |static void update_offset(printbuffer * const buffer)
  531|  30.8k|{
  532|  30.8k|    const unsigned char *buffer_pointer = NULL;
  533|  30.8k|    if ((buffer == NULL) || (buffer->buffer == NULL))
  534|      0|    {
  535|      0|        return;
  536|      0|    }
  537|  30.8k|    buffer_pointer = buffer->buffer + buffer->offset;
  538|       |
  539|  30.8k|    buffer->offset += strlen((const char*)buffer_pointer);
  540|  30.8k|}
  541|       |
  542|       |/* securely comparison of floating-point variables */
  543|       |static cJSON_bool compare_double(double a, double b)
  544|    206|{
  545|    206|    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
  546|    206|    return (fabs(a - b) <= maxVal * DBL_EPSILON);
  547|    206|}
  548|       |
  549|       |/* Render the number nicely from the given item into a string. */
  550|       |static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
  551|  2.85k|{
  552|  2.85k|    unsigned char *output_pointer = NULL;
  553|  2.85k|    double d = item->valuedouble;
  554|  2.85k|    int length = 0;
  555|  2.85k|    size_t i = 0;
  556|  2.85k|    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
  557|  2.85k|    unsigned char decimal_point = get_decimal_point();
  558|  2.85k|    double test = 0.0;
  559|       |
  560|  2.85k|    if (output_buffer == NULL)
  561|      0|    {
  562|      0|        return false;
  563|      0|    }
  564|       |
  565|       |    /* This checks for NaN and Infinity */
  566|  2.85k|    if (isnan(d) || isinf(d))
  567|    147|    {
  568|    147|        length = sprintf((char*)number_buffer, "null");
  569|    147|    }
  570|  2.70k|	else if(d == (double)item->valueint)
  571|  2.50k|	{
  572|  2.50k|		length = sprintf((char*)number_buffer, "%d", item->valueint);
  573|  2.50k|	}
  574|    206|    else
  575|    206|    {
  576|       |        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
  577|    206|        length = sprintf((char*)number_buffer, "%1.15g", d);
  578|       |
  579|       |        /* Check whether the original double can be recovered */
  580|    206|        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
  581|     24|        {
  582|       |            /* If not, print with 17 decimal places of precision */
  583|     24|            length = sprintf((char*)number_buffer, "%1.17g", d);
  584|     24|        }
  585|    206|    }
  586|       |
  587|       |    /* sprintf failed or buffer overrun occurred */
  588|  2.85k|    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
  589|      0|    {
  590|      0|        return false;
  591|      0|    }
  592|       |
  593|       |    /* reserve appropriate space in the output */
  594|  2.85k|    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
  595|  2.85k|    if (output_pointer == NULL)
  596|      0|    {
  597|      0|        return false;
  598|      0|    }
  599|       |
  600|       |    /* copy the printed number to the output and replace locale
  601|       |     * dependent decimal point with '.' */
  602|  10.4k|    for (i = 0; i < ((size_t)length); i++)
  603|  7.61k|    {
  604|  7.61k|        if (number_buffer[i] == decimal_point)
  605|    198|        {
  606|    198|            output_pointer[i] = '.';
  607|    198|            continue;
  608|    198|        }
  609|       |
  610|  7.41k|        output_pointer[i] = number_buffer[i];
  611|  7.41k|    }
  612|  2.85k|    output_pointer[i] = '\0';
  613|       |
  614|  2.85k|    output_buffer->offset += (size_t)length;
  615|       |
  616|  2.85k|    return true;
  617|  2.85k|}
  618|       |
  619|       |/* parse 4 digit hexadecimal number */
  620|       |static unsigned parse_hex4(const unsigned char * const input)
  621|  2.07k|{
  622|  2.07k|    unsigned int h = 0;
  623|  2.07k|    size_t i = 0;
  624|       |
  625|  2.81k|    for (i = 0; i < 4; i++)
  626|  2.81k|    {
  627|       |        /* parse digit */
  628|  2.81k|        if ((input[i] >= '0') && (input[i] <= '9'))
  629|      8|        {
  630|      8|            h += (unsigned int) input[i] - '0';
  631|      8|        }
  632|  2.80k|        else if ((input[i] >= 'A') && (input[i] <= 'F'))
  633|      5|        {
  634|      5|            h += (unsigned int) 10 + input[i] - 'A';
  635|      5|        }
  636|  2.80k|        else if ((input[i] >= 'a') && (input[i] <= 'f'))
  637|    727|        {
  638|    727|            h += (unsigned int) 10 + input[i] - 'a';
  639|    727|        }
  640|  2.07k|        else /* invalid */
  641|  2.07k|        {
  642|  2.07k|            return 0;
  643|  2.07k|        }
  644|       |
  645|    740|        if (i < 3)
  646|    740|        {
  647|       |            /* shift left to make place for the next nibble */
  648|    740|            h = h << 4;
  649|    740|        }
  650|    740|    }
  651|       |
  652|      0|    return h;
  653|  2.07k|}
  654|       |
  655|       |/* converts a UTF-16 literal to UTF-8
  656|       | * A literal can be one or two sequences of the form \uXXXX */
  657|       |static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
  658|  2.09k|{
  659|  2.09k|    long unsigned int codepoint = 0;
  660|  2.09k|    unsigned int first_code = 0;
  661|  2.09k|    const unsigned char *first_sequence = input_pointer;
  662|  2.09k|    unsigned char utf8_length = 0;
  663|  2.09k|    unsigned char utf8_position = 0;
  664|  2.09k|    unsigned char sequence_length = 0;
  665|  2.09k|    unsigned char first_byte_mark = 0;
  666|       |
  667|  2.09k|    if ((input_end - first_sequence) < 6)
  668|     18|    {
  669|       |        /* input ends unexpectedly */
  670|     18|        goto fail;
  671|     18|    }
  672|       |
  673|       |    /* get the first utf16 sequence */
  674|  2.07k|    first_code = parse_hex4(first_sequence + 2);
  675|       |
  676|       |    /* check that the code is valid */
  677|  2.07k|    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
  678|      0|    {
  679|      0|        goto fail;
  680|      0|    }
  681|       |
  682|       |    /* UTF16 surrogate pair */
  683|  2.07k|    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
  684|      0|    {
  685|      0|        const unsigned char *second_sequence = first_sequence + 6;
  686|      0|        unsigned int second_code = 0;
  687|      0|        sequence_length = 12; /* \uXXXX\uXXXX */
  688|       |
  689|      0|        if ((input_end - second_sequence) < 6)
  690|      0|        {
  691|       |            /* input ends unexpectedly */
  692|      0|            goto fail;
  693|      0|        }
  694|       |
  695|      0|        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
  696|      0|        {
  697|       |            /* missing second half of the surrogate pair */
  698|      0|            goto fail;
  699|      0|        }
  700|       |
  701|       |        /* get the second utf16 sequence */
  702|      0|        second_code = parse_hex4(second_sequence + 2);
  703|       |        /* check that the code is valid */
  704|      0|        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
  705|      0|        {
  706|       |            /* invalid second half of the surrogate pair */
  707|      0|            goto fail;
  708|      0|        }
  709|       |
  710|       |
  711|       |        /* calculate the unicode codepoint from the surrogate pair */
  712|      0|        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
  713|      0|    }
  714|  2.07k|    else
  715|  2.07k|    {
  716|  2.07k|        sequence_length = 6; /* \uXXXX */
  717|  2.07k|        codepoint = first_code;
  718|  2.07k|    }
  719|       |
  720|       |    /* encode as UTF-8
  721|       |     * takes at maximum 4 bytes to encode:
  722|       |     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
  723|  2.07k|    if (codepoint < 0x80)
  724|  2.07k|    {
  725|       |        /* normal ascii, encoding 0xxxxxxx */
  726|  2.07k|        utf8_length = 1;
  727|  2.07k|    }
  728|      0|    else if (codepoint < 0x800)
  729|      0|    {
  730|       |        /* two bytes, encoding 110xxxxx 10xxxxxx */
  731|      0|        utf8_length = 2;
  732|      0|        first_byte_mark = 0xC0; /* 11000000 */
  733|      0|    }
  734|      0|    else if (codepoint < 0x10000)
  735|      0|    {
  736|       |        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
  737|      0|        utf8_length = 3;
  738|      0|        first_byte_mark = 0xE0; /* 11100000 */
  739|      0|    }
  740|      0|    else if (codepoint <= 0x10FFFF)
  741|      0|    {
  742|       |        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
  743|      0|        utf8_length = 4;
  744|      0|        first_byte_mark = 0xF0; /* 11110000 */
  745|      0|    }
  746|      0|    else
  747|      0|    {
  748|       |        /* invalid unicode codepoint */
  749|      0|        goto fail;
  750|      0|    }
  751|       |
  752|       |    /* encode as utf8 */
  753|  2.07k|    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
  754|      0|    {
  755|       |        /* 10xxxxxx */
  756|      0|        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
  757|      0|        codepoint >>= 6;
  758|      0|    }
  759|       |    /* encode first byte */
  760|  2.07k|    if (utf8_length > 1)
  761|      0|    {
  762|      0|        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
  763|      0|    }
  764|  2.07k|    else
  765|  2.07k|    {
  766|  2.07k|        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
  767|  2.07k|    }
  768|       |
  769|  2.07k|    *output_pointer += utf8_length;
  770|       |
  771|  2.07k|    return sequence_length;
  772|       |
  773|     18|fail:
  774|     18|    return 0;
  775|  2.07k|}
  776|       |
  777|       |/* Parse the input text into an unescaped cinput, and populate item. */
  778|       |static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
  779|  30.5k|{
  780|  30.5k|    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
  781|  30.5k|    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
  782|  30.5k|    unsigned char *output_pointer = NULL;
  783|  30.5k|    unsigned char *output = NULL;
  784|       |
  785|       |    /* not a string */
  786|  30.5k|    if (buffer_at_offset(input_buffer)[0] != '\"')
  787|     67|    {
  788|     67|        goto fail;
  789|     67|    }
  790|       |
  791|  30.5k|    {
  792|       |        /* calculate approximate size of the output (overestimate) */
  793|  30.5k|        size_t allocation_length = 0;
  794|  30.5k|        size_t skipped_bytes = 0;
  795|   303k|        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
  796|   272k|        {
  797|       |            /* is escape sequence */
  798|   272k|            if (input_end[0] == '\\')
  799|  8.87k|            {
  800|  8.87k|                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
  801|      0|                {
  802|       |                    /* prevent buffer overflow when last input character is a backslash */
  803|      0|                    goto fail;
  804|      0|                }
  805|  8.87k|                skipped_bytes++;
  806|  8.87k|                input_end++;
  807|  8.87k|            }
  808|   272k|            input_end++;
  809|   272k|        }
  810|  30.5k|        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
  811|     19|        {
  812|     19|            goto fail; /* string ended unexpectedly */
  813|     19|        }
  814|       |
  815|       |        /* This is at most how much we need for the output */
  816|  30.5k|        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
  817|  30.5k|        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
  818|  30.5k|        if (output == NULL)
  819|      0|        {
  820|      0|            goto fail; /* allocation failure */
  821|      0|        }
  822|  30.5k|    }
  823|       |
  824|  30.5k|    output_pointer = output;
  825|       |    /* loop through the string literal */
  826|   293k|    while (input_pointer < input_end)
  827|   263k|    {
  828|   263k|        if (*input_pointer != '\\')
  829|   255k|        {
  830|   255k|            *output_pointer++ = *input_pointer++;
  831|   255k|        }
  832|       |        /* escape sequence */
  833|  7.85k|        else
  834|  7.85k|        {
  835|  7.85k|            unsigned char sequence_length = 2;
  836|  7.85k|            if ((input_end - input_pointer) < 1)
  837|      0|            {
  838|      0|                goto fail;
  839|      0|            }
  840|       |
  841|  7.85k|            switch (input_pointer[1])
  842|  7.85k|            {
  843|    534|                case 'b':
  844|    534|                    *output_pointer++ = '\b';
  845|    534|                    break;
  846|    750|                case 'f':
  847|    750|                    *output_pointer++ = '\f';
  848|    750|                    break;
  849|    759|                case 'n':
  850|    759|                    *output_pointer++ = '\n';
  851|    759|                    break;
  852|    488|                case 'r':
  853|    488|                    *output_pointer++ = '\r';
  854|    488|                    break;
  855|    341|                case 't':
  856|    341|                    *output_pointer++ = '\t';
  857|    341|                    break;
  858|    986|                case '\"':
  859|  2.85k|                case '\\':
  860|  2.85k|                case '/':
  861|  2.85k|                    *output_pointer++ = input_pointer[1];
  862|  2.85k|                    break;
  863|       |
  864|       |                /* UTF-16 literal */
  865|  2.09k|                case 'u':
  866|  2.09k|                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
  867|  2.09k|                    if (sequence_length == 0)
  868|     18|                    {
  869|       |                        /* failed to convert UTF16-literal to UTF-8 */
  870|     18|                        goto fail;
  871|     18|                    }
  872|  2.07k|                    break;
  873|       |
  874|  2.07k|                default:
  875|     35|                    goto fail;
  876|  7.85k|            }
  877|  7.80k|            input_pointer += sequence_length;
  878|  7.80k|        }
  879|   263k|    }
  880|       |
  881|       |    /* zero terminate the output */
  882|  30.4k|    *output_pointer = '\0';
  883|       |
  884|  30.4k|    item->type = cJSON_String;
  885|  30.4k|    item->valuestring = (char*)output;
  886|       |
  887|  30.4k|    input_buffer->offset = (size_t) (input_end - input_buffer->content);
  888|  30.4k|    input_buffer->offset++;
  889|       |
  890|  30.4k|    return true;
  891|       |
  892|    139|fail:
  893|    139|    if (output != NULL)
  894|     53|    {
  895|     53|        input_buffer->hooks.deallocate(output);
  896|     53|    }
  897|       |
  898|    139|    if (input_pointer != NULL)
  899|    139|    {
  900|    139|        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
  901|    139|    }
  902|       |
  903|    139|    return false;
  904|  30.5k|}
  905|       |
  906|       |/* Render the cstring provided to an escaped version that can be printed. */
  907|       |static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
  908|  18.2k|{
  909|  18.2k|    const unsigned char *input_pointer = NULL;
  910|  18.2k|    unsigned char *output = NULL;
  911|  18.2k|    unsigned char *output_pointer = NULL;
  912|  18.2k|    size_t output_length = 0;
  913|       |    /* numbers of additional characters needed for escaping */
  914|  18.2k|    size_t escape_characters = 0;
  915|       |
  916|  18.2k|    if (output_buffer == NULL)
  917|      0|    {
  918|      0|        return false;
  919|      0|    }
  920|       |
  921|       |    /* empty string */
  922|  18.2k|    if (input == NULL)
  923|      0|    {
  924|      0|        output = ensure(output_buffer, sizeof("\"\""));
  925|      0|        if (output == NULL)
  926|      0|        {
  927|      0|            return false;
  928|      0|        }
  929|      0|        strcpy((char*)output, "\"\"");
  930|       |
  931|      0|        return true;
  932|      0|    }
  933|       |
  934|       |    /* set "flag" to 1 if something needs to be escaped */
  935|   165k|    for (input_pointer = input; *input_pointer; input_pointer++)
  936|   147k|    {
  937|   147k|        switch (*input_pointer)
  938|   147k|        {
  939|    305|            case '\"':
  940|    305|            case '\\':
  941|    305|            case '\b':
  942|    307|            case '\f':
  943|    320|            case '\n':
  944|    322|            case '\r':
  945|    334|            case '\t':
  946|       |                /* one character escape sequence */
  947|    334|                escape_characters++;
  948|    334|                break;
  949|   147k|            default:
  950|   147k|                if (*input_pointer < 32)
  951|    157|                {
  952|       |                    /* UTF-16 escape sequence uXXXX */
  953|    157|                    escape_characters += 5;
  954|    157|                }
  955|   147k|                break;
  956|   147k|        }
  957|   147k|    }
  958|  18.2k|    output_length = (size_t)(input_pointer - input) + escape_characters;
  959|       |
  960|  18.2k|    output = ensure(output_buffer, output_length + sizeof("\"\""));
  961|  18.2k|    if (output == NULL)
  962|      0|    {
  963|      0|        return false;
  964|      0|    }
  965|       |
  966|       |    /* no characters have to be escaped */
  967|  18.2k|    if (escape_characters == 0)
  968|  17.9k|    {
  969|  17.9k|        output[0] = '\"';
  970|  17.9k|        memcpy(output + 1, input, output_length);
  971|  17.9k|        output[output_length + 1] = '\"';
  972|  17.9k|        output[output_length + 2] = '\0';
  973|       |
  974|  17.9k|        return true;
  975|  17.9k|    }
  976|       |
  977|    296|    output[0] = '\"';
  978|    296|    output_pointer = output + 1;
  979|       |    /* copy the string */
  980|  3.52k|    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
  981|  3.22k|    {
  982|  3.22k|        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
  983|  2.73k|        {
  984|       |            /* normal character, copy */
  985|  2.73k|            *output_pointer = *input_pointer;
  986|  2.73k|        }
  987|    491|        else
  988|    491|        {
  989|       |            /* character needs to be escaped */
  990|    491|            *output_pointer++ = '\\';
  991|    491|            switch (*input_pointer)
  992|    491|            {
  993|      0|                case '\\':
  994|      0|                    *output_pointer = '\\';
  995|      0|                    break;
  996|    305|                case '\"':
  997|    305|                    *output_pointer = '\"';
  998|    305|                    break;
  999|      0|                case '\b':
 1000|      0|                    *output_pointer = 'b';
 1001|      0|                    break;
 1002|      2|                case '\f':
 1003|      2|                    *output_pointer = 'f';
 1004|      2|                    break;
 1005|     13|                case '\n':
 1006|     13|                    *output_pointer = 'n';
 1007|     13|                    break;
 1008|      2|                case '\r':
 1009|      2|                    *output_pointer = 'r';
 1010|      2|                    break;
 1011|     12|                case '\t':
 1012|     12|                    *output_pointer = 't';
 1013|     12|                    break;
 1014|    157|                default:
 1015|       |                    /* escape and print as unicode codepoint */
 1016|    157|                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
 1017|    157|                    output_pointer += 4;
 1018|    157|                    break;
 1019|    491|            }
 1020|    491|        }
 1021|  3.22k|    }
 1022|    296|    output[output_length + 1] = '\"';
 1023|    296|    output[output_length + 2] = '\0';
 1024|       |
 1025|    296|    return true;
 1026|    296|}
 1027|       |
 1028|       |/* Invoke print_string_ptr (which is useful) on an item. */
 1029|       |static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
 1030|  7.77k|{
 1031|  7.77k|    return print_string_ptr((unsigned char*)item->valuestring, p);
 1032|  7.77k|}
 1033|       |
 1034|       |/* Predeclare these prototypes. */
 1035|       |static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
 1036|       |static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
 1037|       |static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
 1038|       |static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
 1039|       |static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
 1040|       |static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
 1041|       |
 1042|       |/* Utility to jump whitespace and cr/lf */
 1043|       |static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
 1044|   139k|{
 1045|   139k|    if ((buffer == NULL) || (buffer->content == NULL))
 1046|      0|    {
 1047|      0|        return NULL;
 1048|      0|    }
 1049|       |
 1050|   139k|    if (cannot_access_at_index(buffer, 0))
 1051|      0|    {
 1052|      0|        return buffer;
 1053|      0|    }
 1054|       |
 1055|   264k|    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
 1056|   125k|    {
 1057|   125k|       buffer->offset++;
 1058|   125k|    }
 1059|       |
 1060|   139k|    if (buffer->offset == buffer->length)
 1061|     73|    {
 1062|     73|        buffer->offset--;
 1063|     73|    }
 1064|       |
 1065|   139k|    return buffer;
 1066|   139k|}
 1067|       |
 1068|       |/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
 1069|       |static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
 1070|  1.25k|{
 1071|  1.25k|    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
 1072|      0|    {
 1073|      0|        return NULL;
 1074|      0|    }
 1075|       |
 1076|  1.25k|    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
 1077|      0|    {
 1078|      0|        buffer->offset += 3;
 1079|      0|    }
 1080|       |
 1081|  1.25k|    return buffer;
 1082|  1.25k|}
 1083|       |
 1084|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
 1085|  1.25k|{
 1086|  1.25k|    size_t buffer_length;
 1087|       |
 1088|  1.25k|    if (NULL == value)
 1089|      0|    {
 1090|      0|        return NULL;
 1091|      0|    }
 1092|       |
 1093|       |    /* Adding null character size due to require_null_terminated. */
 1094|  1.25k|    buffer_length = strlen(value) + sizeof("");
 1095|       |
 1096|  1.25k|    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);
 1097|  1.25k|}
 1098|       |
 1099|       |/* Parse an object - create a new root, and populate. */
 1100|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
 1101|  1.25k|{
 1102|  1.25k|    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
 1103|  1.25k|    cJSON *item = NULL;
 1104|       |
 1105|       |    /* reset error position */
 1106|  1.25k|    global_error.json = NULL;
 1107|  1.25k|    global_error.position = 0;
 1108|       |
 1109|  1.25k|    if (value == NULL || 0 == buffer_length)
 1110|      0|    {
 1111|      0|        goto fail;
 1112|      0|    }
 1113|       |
 1114|  1.25k|    buffer.content = (const unsigned char*)value;
 1115|  1.25k|    buffer.length = buffer_length;
 1116|  1.25k|    buffer.offset = 0;
 1117|  1.25k|    buffer.hooks = global_hooks;
 1118|       |
 1119|  1.25k|    item = cJSON_New_Item(&global_hooks);
 1120|  1.25k|    if (item == NULL) /* memory fail */
 1121|      0|    {
 1122|      0|        goto fail;
 1123|      0|    }
 1124|       |
 1125|  1.25k|    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
 1126|    672|    {
 1127|       |        /* parse failure. ep is set. */
 1128|    672|        goto fail;
 1129|    672|    }
 1130|       |
 1131|       |    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
 1132|    584|    if (require_null_terminated)
 1133|      0|    {
 1134|      0|        buffer_skip_whitespace(&buffer);
 1135|      0|        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
 1136|      0|        {
 1137|      0|            goto fail;
 1138|      0|        }
 1139|      0|    }
 1140|    584|    if (return_parse_end)
 1141|      0|    {
 1142|      0|        *return_parse_end = (const char*)buffer_at_offset(&buffer);
 1143|      0|    }
 1144|       |
 1145|    584|    return item;
 1146|       |
 1147|    672|fail:
 1148|    672|    if (item != NULL)
 1149|    672|    {
 1150|    672|        cJSON_Delete(item);
 1151|    672|    }
 1152|       |
 1153|    672|    if (value != NULL)
 1154|    672|    {
 1155|    672|        error local_error;
 1156|    672|        local_error.json = (const unsigned char*)value;
 1157|    672|        local_error.position = 0;
 1158|       |
 1159|    672|        if (buffer.offset < buffer.length)
 1160|    666|        {
 1161|    666|            local_error.position = buffer.offset;
 1162|    666|        }
 1163|      6|        else if (buffer.length > 0)
 1164|      6|        {
 1165|      6|            local_error.position = buffer.length - 1;
 1166|      6|        }
 1167|       |
 1168|    672|        if (return_parse_end != NULL)
 1169|      0|        {
 1170|      0|            *return_parse_end = (const char*)local_error.json + local_error.position;
 1171|      0|        }
 1172|       |
 1173|    672|        global_error = local_error;
 1174|    672|    }
 1175|       |
 1176|    672|    return NULL;
 1177|    584|}
 1178|       |
 1179|       |/* Default options for cJSON_Parse */
 1180|       |CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
 1181|  1.25k|{
 1182|  1.25k|    return cJSON_ParseWithOpts(value, 0, 0);
 1183|  1.25k|}
 1184|       |
 1185|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)
 1186|      0|{
 1187|      0|    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
 1188|      0|}
 1189|       |
 1190|      0|#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))
 1191|       |
 1192|       |static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
 1193|     97|{
 1194|     97|    static const size_t default_buffer_size = 256;
 1195|     97|    printbuffer buffer[1];
 1196|     97|    unsigned char *printed = NULL;
 1197|       |
 1198|     97|    memset(buffer, 0, sizeof(buffer));
 1199|       |
 1200|       |    /* create buffer */
 1201|     97|    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
 1202|     97|    buffer->length = default_buffer_size;
 1203|     97|    buffer->format = format;
 1204|     97|    buffer->hooks = *hooks;
 1205|     97|    if (buffer->buffer == NULL)
 1206|      0|    {
 1207|      0|        goto fail;
 1208|      0|    }
 1209|       |
 1210|       |    /* print the value */
 1211|     97|    if (!print_value(item, buffer))
 1212|      0|    {
 1213|      0|        goto fail;
 1214|      0|    }
 1215|     97|    update_offset(buffer);
 1216|       |
 1217|       |    /* check if reallocate is available */
 1218|     97|    if (hooks->reallocate != NULL)
 1219|     97|    {
 1220|     97|        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
 1221|     97|        if (printed == NULL) {
 1222|      0|            goto fail;
 1223|      0|        }
 1224|     97|        buffer->buffer = NULL;
 1225|     97|    }
 1226|      0|    else /* otherwise copy the JSON over to a new buffer */
 1227|      0|    {
 1228|      0|        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
 1229|      0|        if (printed == NULL)
 1230|      0|        {
 1231|      0|            goto fail;
 1232|      0|        }
 1233|      0|        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
 1234|      0|        printed[buffer->offset] = '\0'; /* just to be sure */
 1235|       |
 1236|       |        /* free the buffer */
 1237|      0|        hooks->deallocate(buffer->buffer);
 1238|      0|    }
 1239|       |
 1240|     97|    return printed;
 1241|       |
 1242|      0|fail:
 1243|      0|    if (buffer->buffer != NULL)
 1244|      0|    {
 1245|      0|        hooks->deallocate(buffer->buffer);
 1246|      0|    }
 1247|       |
 1248|      0|    if (printed != NULL)
 1249|      0|    {
 1250|      0|        hooks->deallocate(printed);
 1251|      0|    }
 1252|       |
 1253|      0|    return NULL;
 1254|     97|}
 1255|       |
 1256|       |/* Render a cJSON item/entity/structure to text. */
 1257|       |CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
 1258|     30|{
 1259|     30|    return (char*)print(item, true, &global_hooks);
 1260|     30|}
 1261|       |
 1262|       |CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
 1263|     67|{
 1264|     67|    return (char*)print(item, false, &global_hooks);
 1265|     67|}
 1266|       |
 1267|       |CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
 1268|    487|{
 1269|    487|    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 1270|       |
 1271|    487|    if (prebuffer < 0)
 1272|      0|    {
 1273|      0|        return NULL;
 1274|      0|    }
 1275|       |
 1276|    487|    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
 1277|    487|    if (!p.buffer)
 1278|      0|    {
 1279|      0|        return NULL;
 1280|      0|    }
 1281|       |
 1282|    487|    p.length = (size_t)prebuffer;
 1283|    487|    p.offset = 0;
 1284|    487|    p.noalloc = false;
 1285|    487|    p.format = fmt;
 1286|    487|    p.hooks = global_hooks;
 1287|       |
 1288|    487|    if (!print_value(item, &p))
 1289|      0|    {
 1290|      0|        global_hooks.deallocate(p.buffer);
 1291|      0|        return NULL;
 1292|      0|    }
 1293|       |
 1294|    487|    return (char*)p.buffer;
 1295|    487|}
 1296|       |
 1297|       |CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
 1298|      0|{
 1299|      0|    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 1300|       |
 1301|      0|    if ((length < 0) || (buffer == NULL))
 1302|      0|    {
 1303|      0|        return false;
 1304|      0|    }
 1305|       |
 1306|      0|    p.buffer = (unsigned char*)buffer;
 1307|      0|    p.length = (size_t)length;
 1308|      0|    p.offset = 0;
 1309|      0|    p.noalloc = true;
 1310|      0|    p.format = format;
 1311|      0|    p.hooks = global_hooks;
 1312|       |
 1313|      0|    return print_value(item, &p);
 1314|      0|}
 1315|       |
 1316|       |/* Parser core - when encountering text, process appropriately. */
 1317|       |static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
 1318|  45.2k|{
 1319|  45.2k|    if ((input_buffer == NULL) || (input_buffer->content == NULL))
 1320|      0|    {
 1321|      0|        return false; /* no input */
 1322|      0|    }
 1323|       |
 1324|       |    /* parse the different types of values */
 1325|       |    /* null */
 1326|  45.2k|    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
 1327|  1.16k|    {
 1328|  1.16k|        item->type = cJSON_NULL;
 1329|  1.16k|        input_buffer->offset += 4;
 1330|  1.16k|        return true;
 1331|  1.16k|    }
 1332|       |    /* false */
 1333|  44.0k|    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
 1334|    615|    {
 1335|    615|        item->type = cJSON_False;
 1336|    615|        input_buffer->offset += 5;
 1337|    615|        return true;
 1338|    615|    }
 1339|       |    /* true */
 1340|  43.4k|    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
 1341|    161|    {
 1342|    161|        item->type = cJSON_True;
 1343|    161|        item->valueint = 1;
 1344|    161|        input_buffer->offset += 4;
 1345|    161|        return true;
 1346|    161|    }
 1347|       |    /* string */
 1348|  43.2k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
 1349|  13.1k|    {
 1350|  13.1k|        return parse_string(item, input_buffer);
 1351|  13.1k|    }
 1352|       |    /* number */
 1353|  30.0k|    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
 1354|  3.98k|    {
 1355|  3.98k|        return parse_number(item, input_buffer);
 1356|  3.98k|    }
 1357|       |    /* array */
 1358|  26.0k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
 1359|  18.2k|    {
 1360|  18.2k|        return parse_array(item, input_buffer);
 1361|  18.2k|    }
 1362|       |    /* object */
 1363|  7.84k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
 1364|  7.72k|    {
 1365|  7.72k|        return parse_object(item, input_buffer);
 1366|  7.72k|    }
 1367|       |
 1368|    119|    return false;
 1369|  7.84k|}
 1370|       |
 1371|       |/* Render a value to text. */
 1372|       |static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
 1373|  20.9k|{
 1374|  20.9k|    unsigned char *output = NULL;
 1375|       |
 1376|  20.9k|    if ((item == NULL) || (output_buffer == NULL))
 1377|      0|    {
 1378|      0|        return false;
 1379|      0|    }
 1380|       |
 1381|  20.9k|    switch ((item->type) & 0xFF)
 1382|  20.9k|    {
 1383|    534|        case cJSON_NULL:
 1384|    534|            output = ensure(output_buffer, 5);
 1385|    534|            if (output == NULL)
 1386|      0|            {
 1387|      0|                return false;
 1388|      0|            }
 1389|    534|            strcpy((char*)output, "null");
 1390|    534|            return true;
 1391|       |
 1392|    333|        case cJSON_False:
 1393|    333|            output = ensure(output_buffer, 6);
 1394|    333|            if (output == NULL)
 1395|      0|            {
 1396|      0|                return false;
 1397|      0|            }
 1398|    333|            strcpy((char*)output, "false");
 1399|    333|            return true;
 1400|       |
 1401|    131|        case cJSON_True:
 1402|    131|            output = ensure(output_buffer, 5);
 1403|    131|            if (output == NULL)
 1404|      0|            {
 1405|      0|                return false;
 1406|      0|            }
 1407|    131|            strcpy((char*)output, "true");
 1408|    131|            return true;
 1409|       |
 1410|  2.85k|        case cJSON_Number:
 1411|  2.85k|            return print_number(item, output_buffer);
 1412|       |
 1413|      0|        case cJSON_Raw:
 1414|      0|        {
 1415|      0|            size_t raw_length = 0;
 1416|      0|            if (item->valuestring == NULL)
 1417|      0|            {
 1418|      0|                return false;
 1419|      0|            }
 1420|       |
 1421|      0|            raw_length = strlen(item->valuestring) + sizeof("");
 1422|      0|            output = ensure(output_buffer, raw_length);
 1423|      0|            if (output == NULL)
 1424|      0|            {
 1425|      0|                return false;
 1426|      0|            }
 1427|      0|            memcpy(output, item->valuestring, raw_length);
 1428|      0|            return true;
 1429|      0|        }
 1430|       |
 1431|  7.77k|        case cJSON_String:
 1432|  7.77k|            return print_string(item, output_buffer);
 1433|       |
 1434|  5.25k|        case cJSON_Array:
 1435|  5.25k|            return print_array(item, output_buffer);
 1436|       |
 1437|  4.02k|        case cJSON_Object:
 1438|  4.02k|            return print_object(item, output_buffer);
 1439|       |
 1440|      0|        default:
 1441|      0|            return false;
 1442|  20.9k|    }
 1443|  20.9k|}
 1444|       |
 1445|       |/* Build an array from input text. */
 1446|       |static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
 1447|  18.2k|{
 1448|  18.2k|    cJSON *head = NULL; /* head of the linked list */
 1449|  18.2k|    cJSON *current_item = NULL;
 1450|       |
 1451|  18.2k|    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 1452|      3|    {
 1453|      3|        return false; /* to deeply nested */
 1454|      3|    }
 1455|  18.2k|    input_buffer->depth++;
 1456|       |
 1457|  18.2k|    if (buffer_at_offset(input_buffer)[0] != '[')
 1458|      0|    {
 1459|       |        /* not an array */
 1460|      0|        goto fail;
 1461|      0|    }
 1462|       |
 1463|  18.2k|    input_buffer->offset++;
 1464|  18.2k|    buffer_skip_whitespace(input_buffer);
 1465|  18.2k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
 1466|  4.27k|    {
 1467|       |        /* empty array */
 1468|  4.27k|        goto success;
 1469|  4.27k|    }
 1470|       |
 1471|       |    /* check if we skipped to the end of the buffer */
 1472|  13.9k|    if (cannot_access_at_index(input_buffer, 0))
 1473|      0|    {
 1474|      0|        input_buffer->offset--;
 1475|      0|        goto fail;
 1476|      0|    }
 1477|       |
 1478|       |    /* step back to character in front of the first element */
 1479|  13.9k|    input_buffer->offset--;
 1480|       |    /* loop through the comma separated array elements */
 1481|  13.9k|    do
 1482|  26.7k|    {
 1483|       |        /* allocate next item */
 1484|  26.7k|        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 1485|  26.7k|        if (new_item == NULL)
 1486|      0|        {
 1487|      0|            goto fail; /* allocation failure */
 1488|      0|        }
 1489|       |
 1490|       |        /* attach next item to list */
 1491|  26.7k|        if (head == NULL)
 1492|  13.9k|        {
 1493|       |            /* start the linked list */
 1494|  13.9k|            current_item = head = new_item;
 1495|  13.9k|        }
 1496|  12.7k|        else
 1497|  12.7k|        {
 1498|       |            /* add to the end and advance */
 1499|  12.7k|            current_item->next = new_item;
 1500|  12.7k|            new_item->prev = current_item;
 1501|  12.7k|            current_item = new_item;
 1502|  12.7k|        }
 1503|       |
 1504|       |        /* parse next value */
 1505|  26.7k|        input_buffer->offset++;
 1506|  26.7k|        buffer_skip_whitespace(input_buffer);
 1507|  26.7k|        if (!parse_value(current_item, input_buffer))
 1508|  9.65k|        {
 1509|  9.65k|            goto fail; /* failed to parse value */
 1510|  9.65k|        }
 1511|  17.0k|        buffer_skip_whitespace(input_buffer);
 1512|  17.0k|    }
 1513|  17.0k|    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 1514|       |
 1515|  4.31k|    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
 1516|    152|    {
 1517|    152|        goto fail; /* expected end of array */
 1518|    152|    }
 1519|       |
 1520|  8.43k|success:
 1521|  8.43k|    input_buffer->depth--;
 1522|       |
 1523|  8.43k|    if (head != NULL) {
 1524|  4.16k|        head->prev = current_item;
 1525|  4.16k|    }
 1526|       |
 1527|  8.43k|    item->type = cJSON_Array;
 1528|  8.43k|    item->child = head;
 1529|       |
 1530|  8.43k|    input_buffer->offset++;
 1531|       |
 1532|  8.43k|    return true;
 1533|       |
 1534|  9.80k|fail:
 1535|  9.80k|    if (head != NULL)
 1536|  9.80k|    {
 1537|  9.80k|        cJSON_Delete(head);
 1538|  9.80k|    }
 1539|       |
 1540|  9.80k|    return false;
 1541|  4.31k|}
 1542|       |
 1543|       |/* Render an array to text */
 1544|       |static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
 1545|  5.25k|{
 1546|  5.25k|    unsigned char *output_pointer = NULL;
 1547|  5.25k|    size_t length = 0;
 1548|  5.25k|    cJSON *current_element = item->child;
 1549|       |
 1550|  5.25k|    if (output_buffer == NULL)
 1551|      0|    {
 1552|      0|        return false;
 1553|      0|    }
 1554|       |
 1555|       |    /* Compose the output array. */
 1556|       |    /* opening square bracket */
 1557|  5.25k|    output_pointer = ensure(output_buffer, 1);
 1558|  5.25k|    if (output_pointer == NULL)
 1559|      0|    {
 1560|      0|        return false;
 1561|      0|    }
 1562|       |
 1563|  5.25k|    *output_pointer = '[';
 1564|  5.25k|    output_buffer->offset++;
 1565|  5.25k|    output_buffer->depth++;
 1566|       |
 1567|  15.0k|    while (current_element != NULL)
 1568|  9.84k|    {
 1569|  9.84k|        if (!print_value(current_element, output_buffer))
 1570|      0|        {
 1571|      0|            return false;
 1572|      0|        }
 1573|  9.84k|        update_offset(output_buffer);
 1574|  9.84k|        if (current_element->next)
 1575|  7.01k|        {
 1576|  7.01k|            length = (size_t) (output_buffer->format ? 2 : 1);
 1577|  7.01k|            output_pointer = ensure(output_buffer, length + 1);
 1578|  7.01k|            if (output_pointer == NULL)
 1579|      0|            {
 1580|      0|                return false;
 1581|      0|            }
 1582|  7.01k|            *output_pointer++ = ',';
 1583|  7.01k|            if(output_buffer->format)
 1584|  5.33k|            {
 1585|  5.33k|                *output_pointer++ = ' ';
 1586|  5.33k|            }
 1587|  7.01k|            *output_pointer = '\0';
 1588|  7.01k|            output_buffer->offset += length;
 1589|  7.01k|        }
 1590|  9.84k|        current_element = current_element->next;
 1591|  9.84k|    }
 1592|       |
 1593|  5.25k|    output_pointer = ensure(output_buffer, 2);
 1594|  5.25k|    if (output_pointer == NULL)
 1595|      0|    {
 1596|      0|        return false;
 1597|      0|    }
 1598|  5.25k|    *output_pointer++ = ']';
 1599|  5.25k|    *output_pointer = '\0';
 1600|  5.25k|    output_buffer->depth--;
 1601|       |
 1602|  5.25k|    return true;
 1603|  5.25k|}
 1604|       |
 1605|       |/* Build an object from the text. */
 1606|       |static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
 1607|  7.72k|{
 1608|  7.72k|    cJSON *head = NULL; /* linked list head */
 1609|  7.72k|    cJSON *current_item = NULL;
 1610|       |
 1611|  7.72k|    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 1612|      3|    {
 1613|      3|        return false; /* to deeply nested */
 1614|      3|    }
 1615|  7.72k|    input_buffer->depth++;
 1616|       |
 1617|  7.72k|    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
 1618|      0|    {
 1619|      0|        goto fail; /* not an object */
 1620|      0|    }
 1621|       |
 1622|  7.72k|    input_buffer->offset++;
 1623|  7.72k|    buffer_skip_whitespace(input_buffer);
 1624|  7.72k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
 1625|    306|    {
 1626|    306|        goto success; /* empty object */
 1627|    306|    }
 1628|       |
 1629|       |    /* check if we skipped to the end of the buffer */
 1630|  7.41k|    if (cannot_access_at_index(input_buffer, 0))
 1631|      0|    {
 1632|      0|        input_buffer->offset--;
 1633|      0|        goto fail;
 1634|      0|    }
 1635|       |
 1636|       |    /* step back to character in front of the first element */
 1637|  7.41k|    input_buffer->offset--;
 1638|       |    /* loop through the comma separated array elements */
 1639|  7.41k|    do
 1640|  17.3k|    {
 1641|       |        /* allocate next item */
 1642|  17.3k|        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 1643|  17.3k|        if (new_item == NULL)
 1644|      0|        {
 1645|      0|            goto fail; /* allocation failure */
 1646|      0|        }
 1647|       |
 1648|       |        /* attach next item to list */
 1649|  17.3k|        if (head == NULL)
 1650|  7.41k|        {
 1651|       |            /* start the linked list */
 1652|  7.41k|            current_item = head = new_item;
 1653|  7.41k|        }
 1654|  9.97k|        else
 1655|  9.97k|        {
 1656|       |            /* add to the end and advance */
 1657|  9.97k|            current_item->next = new_item;
 1658|  9.97k|            new_item->prev = current_item;
 1659|  9.97k|            current_item = new_item;
 1660|  9.97k|        }
 1661|       |
 1662|       |        /* parse the name of the child */
 1663|  17.3k|        input_buffer->offset++;
 1664|  17.3k|        buffer_skip_whitespace(input_buffer);
 1665|  17.3k|        if (!parse_string(current_item, input_buffer))
 1666|     86|        {
 1667|     86|            goto fail; /* failed to parse name */
 1668|     86|        }
 1669|  17.3k|        buffer_skip_whitespace(input_buffer);
 1670|       |
 1671|       |        /* swap valuestring and string, because we parsed the name */
 1672|  17.3k|        current_item->string = current_item->valuestring;
 1673|  17.3k|        current_item->valuestring = NULL;
 1674|       |
 1675|  17.3k|        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
 1676|    102|        {
 1677|    102|            goto fail; /* invalid object */
 1678|    102|        }
 1679|       |
 1680|       |        /* parse the value */
 1681|  17.2k|        input_buffer->offset++;
 1682|  17.2k|        buffer_skip_whitespace(input_buffer);
 1683|  17.2k|        if (!parse_value(current_item, input_buffer))
 1684|    774|        {
 1685|    774|            goto fail; /* failed to parse value */
 1686|    774|        }
 1687|  16.4k|        buffer_skip_whitespace(input_buffer);
 1688|  16.4k|    }
 1689|  16.4k|    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 1690|       |
 1691|  6.45k|    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
 1692|    146|    {
 1693|    146|        goto fail; /* expected end of object */
 1694|    146|    }
 1695|       |
 1696|  6.61k|success:
 1697|  6.61k|    input_buffer->depth--;
 1698|       |
 1699|  6.61k|    if (head != NULL) {
 1700|  6.31k|        head->prev = current_item;
 1701|  6.31k|    }
 1702|       |
 1703|  6.61k|    item->type = cJSON_Object;
 1704|  6.61k|    item->child = head;
 1705|       |
 1706|  6.61k|    input_buffer->offset++;
 1707|  6.61k|    return true;
 1708|       |
 1709|  1.10k|fail:
 1710|  1.10k|    if (head != NULL)
 1711|  1.10k|    {
 1712|  1.10k|        cJSON_Delete(head);
 1713|  1.10k|    }
 1714|       |
 1715|  1.10k|    return false;
 1716|  6.45k|}
 1717|       |
 1718|       |/* Render an object to text. */
 1719|       |static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
 1720|  4.02k|{
 1721|  4.02k|    unsigned char *output_pointer = NULL;
 1722|  4.02k|    size_t length = 0;
 1723|  4.02k|    cJSON *current_item = item->child;
 1724|       |
 1725|  4.02k|    if (output_buffer == NULL)
 1726|      0|    {
 1727|      0|        return false;
 1728|      0|    }
 1729|       |
 1730|       |    /* Compose the output: */
 1731|  4.02k|    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
 1732|  4.02k|    output_pointer = ensure(output_buffer, length + 1);
 1733|  4.02k|    if (output_pointer == NULL)
 1734|      0|    {
 1735|      0|        return false;
 1736|      0|    }
 1737|       |
 1738|  4.02k|    *output_pointer++ = '{';
 1739|  4.02k|    output_buffer->depth++;
 1740|  4.02k|    if (output_buffer->format)
 1741|  3.23k|    {
 1742|  3.23k|        *output_pointer++ = '\n';
 1743|  3.23k|    }
 1744|  4.02k|    output_buffer->offset += length;
 1745|       |
 1746|  14.5k|    while (current_item)
 1747|  10.4k|    {
 1748|  10.4k|        if (output_buffer->format)
 1749|  8.76k|        {
 1750|  8.76k|            size_t i;
 1751|  8.76k|            output_pointer = ensure(output_buffer, output_buffer->depth);
 1752|  8.76k|            if (output_pointer == NULL)
 1753|      0|            {
 1754|      0|                return false;
 1755|      0|            }
 1756|  38.8k|            for (i = 0; i < output_buffer->depth; i++)
 1757|  30.1k|            {
 1758|  30.1k|                *output_pointer++ = '\t';
 1759|  30.1k|            }
 1760|  8.76k|            output_buffer->offset += output_buffer->depth;
 1761|  8.76k|        }
 1762|       |
 1763|       |        /* print key */
 1764|  10.4k|        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
 1765|      0|        {
 1766|      0|            return false;
 1767|      0|        }
 1768|  10.4k|        update_offset(output_buffer);
 1769|       |
 1770|  10.4k|        length = (size_t) (output_buffer->format ? 2 : 1);
 1771|  10.4k|        output_pointer = ensure(output_buffer, length);
 1772|  10.4k|        if (output_pointer == NULL)
 1773|      0|        {
 1774|      0|            return false;
 1775|      0|        }
 1776|  10.4k|        *output_pointer++ = ':';
 1777|  10.4k|        if (output_buffer->format)
 1778|  8.76k|        {
 1779|  8.76k|            *output_pointer++ = '\t';
 1780|  8.76k|        }
 1781|  10.4k|        output_buffer->offset += length;
 1782|       |
 1783|       |        /* print value */
 1784|  10.4k|        if (!print_value(current_item, output_buffer))
 1785|      0|        {
 1786|      0|            return false;
 1787|      0|        }
 1788|  10.4k|        update_offset(output_buffer);
 1789|       |
 1790|       |        /* print comma if not last */
 1791|  10.4k|        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
 1792|  10.4k|        output_pointer = ensure(output_buffer, length + 1);
 1793|  10.4k|        if (output_pointer == NULL)
 1794|      0|        {
 1795|      0|            return false;
 1796|      0|        }
 1797|  10.4k|        if (current_item->next)
 1798|  6.63k|        {
 1799|  6.63k|            *output_pointer++ = ',';
 1800|  6.63k|        }
 1801|       |
 1802|  10.4k|        if (output_buffer->format)
 1803|  8.76k|        {
 1804|  8.76k|            *output_pointer++ = '\n';
 1805|  8.76k|        }
 1806|  10.4k|        *output_pointer = '\0';
 1807|  10.4k|        output_buffer->offset += length;
 1808|       |
 1809|  10.4k|        current_item = current_item->next;
 1810|  10.4k|    }
 1811|       |
 1812|  4.02k|    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
 1813|  4.02k|    if (output_pointer == NULL)
 1814|      0|    {
 1815|      0|        return false;
 1816|      0|    }
 1817|  4.02k|    if (output_buffer->format)
 1818|  3.23k|    {
 1819|  3.23k|        size_t i;
 1820|  11.1k|        for (i = 0; i < (output_buffer->depth - 1); i++)
 1821|  7.88k|        {
 1822|  7.88k|            *output_pointer++ = '\t';
 1823|  7.88k|        }
 1824|  3.23k|    }
 1825|  4.02k|    *output_pointer++ = '}';
 1826|  4.02k|    *output_pointer = '\0';
 1827|  4.02k|    output_buffer->depth--;
 1828|       |
 1829|  4.02k|    return true;
 1830|  4.02k|}
 1831|       |
 1832|       |/* Get Array size/item / object item. */
 1833|       |CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
 1834|      0|{
 1835|      0|    cJSON *child = NULL;
 1836|      0|    size_t size = 0;
 1837|       |
 1838|      0|    if (array == NULL)
 1839|      0|    {
 1840|      0|        return 0;
 1841|      0|    }
 1842|       |
 1843|      0|    child = array->child;
 1844|       |
 1845|      0|    while(child != NULL)
 1846|      0|    {
 1847|      0|        size++;
 1848|      0|        child = child->next;
 1849|      0|    }
 1850|       |
 1851|       |    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
 1852|       |
 1853|      0|    return (int)size;
 1854|      0|}
 1855|       |
 1856|       |static cJSON* get_array_item(const cJSON *array, size_t index)
 1857|      0|{
 1858|      0|    cJSON *current_child = NULL;
 1859|       |
 1860|      0|    if (array == NULL)
 1861|      0|    {
 1862|      0|        return NULL;
 1863|      0|    }
 1864|       |
 1865|      0|    current_child = array->child;
 1866|      0|    while ((current_child != NULL) && (index > 0))
 1867|      0|    {
 1868|      0|        index--;
 1869|      0|        current_child = current_child->next;
 1870|      0|    }
 1871|       |
 1872|      0|    return current_child;
 1873|      0|}
 1874|       |
 1875|       |CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
 1876|      0|{
 1877|      0|    if (index < 0)
 1878|      0|    {
 1879|      0|        return NULL;
 1880|      0|    }
 1881|       |
 1882|      0|    return get_array_item(array, (size_t)index);
 1883|      0|}
 1884|       |
 1885|       |static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
 1886|      0|{
 1887|      0|    cJSON *current_element = NULL;
 1888|       |
 1889|      0|    if ((object == NULL) || (name == NULL))
 1890|      0|    {
 1891|      0|        return NULL;
 1892|      0|    }
 1893|       |
 1894|      0|    current_element = object->child;
 1895|      0|    if (case_sensitive)
 1896|      0|    {
 1897|      0|        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
 1898|      0|        {
 1899|      0|            current_element = current_element->next;
 1900|      0|        }
 1901|      0|    }
 1902|      0|    else
 1903|      0|    {
 1904|      0|        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
 1905|      0|        {
 1906|      0|            current_element = current_element->next;
 1907|      0|        }
 1908|      0|    }
 1909|       |
 1910|      0|    if ((current_element == NULL) || (current_element->string == NULL)) {
 1911|      0|        return NULL;
 1912|      0|    }
 1913|       |
 1914|      0|    return current_element;
 1915|      0|}
 1916|       |
 1917|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
 1918|      0|{
 1919|      0|    return get_object_item(object, string, false);
 1920|      0|}
 1921|       |
 1922|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
 1923|      0|{
 1924|      0|    return get_object_item(object, string, true);
 1925|      0|}
 1926|       |
 1927|       |CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
 1928|      0|{
 1929|      0|    return cJSON_GetObjectItem(object, string) ? 1 : 0;
 1930|      0|}
 1931|       |
 1932|       |/* Utility for array list handling. */
 1933|       |static void suffix_object(cJSON *prev, cJSON *item)
 1934|      0|{
 1935|      0|    prev->next = item;
 1936|      0|    item->prev = prev;
 1937|      0|}
 1938|       |
 1939|       |/* Utility for handling references. */
 1940|       |static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
 1941|      0|{
 1942|      0|    cJSON *reference = NULL;
 1943|      0|    if (item == NULL)
 1944|      0|    {
 1945|      0|        return NULL;
 1946|      0|    }
 1947|       |
 1948|      0|    reference = cJSON_New_Item(hooks);
 1949|      0|    if (reference == NULL)
 1950|      0|    {
 1951|      0|        return NULL;
 1952|      0|    }
 1953|       |
 1954|      0|    memcpy(reference, item, sizeof(cJSON));
 1955|      0|    reference->string = NULL;
 1956|      0|    reference->type |= cJSON_IsReference;
 1957|      0|    reference->next = reference->prev = NULL;
 1958|      0|    return reference;
 1959|      0|}
 1960|       |
 1961|       |static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
 1962|      0|{
 1963|      0|    cJSON *child = NULL;
 1964|       |
 1965|      0|    if ((item == NULL) || (array == NULL) || (array == item))
 1966|      0|    {
 1967|      0|        return false;
 1968|      0|    }
 1969|       |
 1970|      0|    child = array->child;
 1971|       |    /*
 1972|       |     * To find the last item in array quickly, we use prev in array
 1973|       |     */
 1974|      0|    if (child == NULL)
 1975|      0|    {
 1976|       |        /* list is empty, start new one */
 1977|      0|        array->child = item;
 1978|      0|        item->prev = item;
 1979|      0|        item->next = NULL;
 1980|      0|    }
 1981|      0|    else
 1982|      0|    {
 1983|       |        /* append to the end */
 1984|      0|        if (child->prev)
 1985|      0|        {
 1986|      0|            suffix_object(child->prev, item);
 1987|      0|            array->child->prev = item;
 1988|      0|        }
 1989|      0|    }
 1990|       |
 1991|      0|    return true;
 1992|      0|}
 1993|       |
 1994|       |/* Add item to array/object. */
 1995|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)
 1996|      0|{
 1997|      0|    return add_item_to_array(array, item);
 1998|      0|}
 1999|       |
 2000|       |#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
 2001|       |    #pragma GCC diagnostic push
 2002|       |#endif
 2003|       |#ifdef __GNUC__
 2004|       |#pragma GCC diagnostic ignored "-Wcast-qual"
 2005|       |#endif
 2006|       |/* helper function to cast away const */
 2007|       |static void* cast_away_const(const void* string)
 2008|      0|{
 2009|      0|    return (void*)string;
 2010|      0|}
 2011|       |#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
 2012|       |    #pragma GCC diagnostic pop
 2013|       |#endif
 2014|       |
 2015|       |
 2016|       |static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
 2017|      0|{
 2018|      0|    char *new_key = NULL;
 2019|      0|    int new_type = cJSON_Invalid;
 2020|       |
 2021|      0|    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))
 2022|      0|    {
 2023|      0|        return false;
 2024|      0|    }
 2025|       |
 2026|      0|    if (constant_key)
 2027|      0|    {
 2028|      0|        new_key = (char*)cast_away_const(string);
 2029|      0|        new_type = item->type | cJSON_StringIsConst;
 2030|      0|    }
 2031|      0|    else
 2032|      0|    {
 2033|      0|        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
 2034|      0|        if (new_key == NULL)
 2035|      0|        {
 2036|      0|            return false;
 2037|      0|        }
 2038|       |
 2039|      0|        new_type = item->type & ~cJSON_StringIsConst;
 2040|      0|    }
 2041|       |
 2042|      0|    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
 2043|      0|    {
 2044|      0|        hooks->deallocate(item->string);
 2045|      0|    }
 2046|       |
 2047|      0|    item->string = new_key;
 2048|      0|    item->type = new_type;
 2049|       |
 2050|      0|    return add_item_to_array(object, item);
 2051|      0|}
 2052|       |
 2053|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
 2054|      0|{
 2055|      0|    return add_item_to_object(object, string, item, &global_hooks, false);
 2056|      0|}
 2057|       |
 2058|       |/* Add an item to an object with constant string as key */
 2059|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
 2060|      0|{
 2061|      0|    return add_item_to_object(object, string, item, &global_hooks, true);
 2062|      0|}
 2063|       |
 2064|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
 2065|      0|{
 2066|      0|    if (array == NULL)
 2067|      0|    {
 2068|      0|        return false;
 2069|      0|    }
 2070|       |
 2071|      0|    return add_item_to_array(array, create_reference(item, &global_hooks));
 2072|      0|}
 2073|       |
 2074|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
 2075|      0|{
 2076|      0|    if ((object == NULL) || (string == NULL))
 2077|      0|    {
 2078|      0|        return false;
 2079|      0|    }
 2080|       |
 2081|      0|    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
 2082|      0|}
 2083|       |
 2084|       |CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
 2085|      0|{
 2086|      0|    cJSON *null = cJSON_CreateNull();
 2087|      0|    if (add_item_to_object(object, name, null, &global_hooks, false))
 2088|      0|    {
 2089|      0|        return null;
 2090|      0|    }
 2091|       |
 2092|      0|    cJSON_Delete(null);
 2093|      0|    return NULL;
 2094|      0|}
 2095|       |
 2096|       |CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
 2097|      0|{
 2098|      0|    cJSON *true_item = cJSON_CreateTrue();
 2099|      0|    if (add_item_to_object(object, name, true_item, &global_hooks, false))
 2100|      0|    {
 2101|      0|        return true_item;
 2102|      0|    }
 2103|       |
 2104|      0|    cJSON_Delete(true_item);
 2105|      0|    return NULL;
 2106|      0|}
 2107|       |
 2108|       |CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
 2109|      0|{
 2110|      0|    cJSON *false_item = cJSON_CreateFalse();
 2111|      0|    if (add_item_to_object(object, name, false_item, &global_hooks, false))
 2112|      0|    {
 2113|      0|        return false_item;
 2114|      0|    }
 2115|       |
 2116|      0|    cJSON_Delete(false_item);
 2117|      0|    return NULL;
 2118|      0|}
 2119|       |
 2120|       |CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
 2121|      0|{
 2122|      0|    cJSON *bool_item = cJSON_CreateBool(boolean);
 2123|      0|    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
 2124|      0|    {
 2125|      0|        return bool_item;
 2126|      0|    }
 2127|       |
 2128|      0|    cJSON_Delete(bool_item);
 2129|      0|    return NULL;
 2130|      0|}
 2131|       |
 2132|       |CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
 2133|      0|{
 2134|      0|    cJSON *number_item = cJSON_CreateNumber(number);
 2135|      0|    if (add_item_to_object(object, name, number_item, &global_hooks, false))
 2136|      0|    {
 2137|      0|        return number_item;
 2138|      0|    }
 2139|       |
 2140|      0|    cJSON_Delete(number_item);
 2141|      0|    return NULL;
 2142|      0|}
 2143|       |
 2144|       |CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
 2145|      0|{
 2146|      0|    cJSON *string_item = cJSON_CreateString(string);
 2147|      0|    if (add_item_to_object(object, name, string_item, &global_hooks, false))
 2148|      0|    {
 2149|      0|        return string_item;
 2150|      0|    }
 2151|       |
 2152|      0|    cJSON_Delete(string_item);
 2153|      0|    return NULL;
 2154|      0|}
 2155|       |
 2156|       |CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
 2157|      0|{
 2158|      0|    cJSON *raw_item = cJSON_CreateRaw(raw);
 2159|      0|    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
 2160|      0|    {
 2161|      0|        return raw_item;
 2162|      0|    }
 2163|       |
 2164|      0|    cJSON_Delete(raw_item);
 2165|      0|    return NULL;
 2166|      0|}
 2167|       |
 2168|       |CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
 2169|      0|{
 2170|      0|    cJSON *object_item = cJSON_CreateObject();
 2171|      0|    if (add_item_to_object(object, name, object_item, &global_hooks, false))
 2172|      0|    {
 2173|      0|        return object_item;
 2174|      0|    }
 2175|       |
 2176|      0|    cJSON_Delete(object_item);
 2177|      0|    return NULL;
 2178|      0|}
 2179|       |
 2180|       |CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
 2181|      0|{
 2182|      0|    cJSON *array = cJSON_CreateArray();
 2183|      0|    if (add_item_to_object(object, name, array, &global_hooks, false))
 2184|      0|    {
 2185|      0|        return array;
 2186|      0|    }
 2187|       |
 2188|      0|    cJSON_Delete(array);
 2189|      0|    return NULL;
 2190|      0|}
 2191|       |
 2192|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
 2193|      0|{
 2194|      0|    if ((parent == NULL) || (item == NULL))
 2195|      0|    {
 2196|      0|        return NULL;
 2197|      0|    }
 2198|       |
 2199|      0|    if (item != parent->child)
 2200|      0|    {
 2201|       |        /* not the first element */
 2202|      0|        item->prev->next = item->next;
 2203|      0|    }
 2204|      0|    if (item->next != NULL)
 2205|      0|    {
 2206|       |        /* not the last element */
 2207|      0|        item->next->prev = item->prev;
 2208|      0|    }
 2209|       |
 2210|      0|    if (item == parent->child)
 2211|      0|    {
 2212|       |        /* first element */
 2213|      0|        parent->child = item->next;
 2214|      0|    }
 2215|      0|    else if (item->next == NULL)
 2216|      0|    {
 2217|       |        /* last element */
 2218|      0|        parent->child->prev = item->prev;
 2219|      0|    }
 2220|       |
 2221|       |    /* make sure the detached item doesn't point anywhere anymore */
 2222|      0|    item->prev = NULL;
 2223|      0|    item->next = NULL;
 2224|       |
 2225|      0|    return item;
 2226|      0|}
 2227|       |
 2228|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
 2229|      0|{
 2230|      0|    if (which < 0)
 2231|      0|    {
 2232|      0|        return NULL;
 2233|      0|    }
 2234|       |
 2235|      0|    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
 2236|      0|}
 2237|       |
 2238|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
 2239|      0|{
 2240|      0|    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
 2241|      0|}
 2242|       |
 2243|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
 2244|      0|{
 2245|      0|    cJSON *to_detach = cJSON_GetObjectItem(object, string);
 2246|       |
 2247|      0|    return cJSON_DetachItemViaPointer(object, to_detach);
 2248|      0|}
 2249|       |
 2250|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
 2251|      0|{
 2252|      0|    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
 2253|       |
 2254|      0|    return cJSON_DetachItemViaPointer(object, to_detach);
 2255|      0|}
 2256|       |
 2257|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
 2258|      0|{
 2259|      0|    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
 2260|      0|}
 2261|       |
 2262|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
 2263|      0|{
 2264|      0|    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
 2265|      0|}
 2266|       |
 2267|       |/* Replace array/object items with new ones. */
 2268|       |CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
 2269|      0|{
 2270|      0|    cJSON *after_inserted = NULL;
 2271|       |
 2272|      0|    if (which < 0 || newitem == NULL)
 2273|      0|    {
 2274|      0|        return false;
 2275|      0|    }
 2276|       |
 2277|      0|    after_inserted = get_array_item(array, (size_t)which);
 2278|      0|    if (after_inserted == NULL)
 2279|      0|    {
 2280|      0|        return add_item_to_array(array, newitem);
 2281|      0|    }
 2282|       |
 2283|      0|    if (after_inserted != array->child && after_inserted->prev == NULL) {
 2284|       |        /* return false if after_inserted is a corrupted array item */
 2285|      0|        return false;
 2286|      0|    }
 2287|       |
 2288|      0|    newitem->next = after_inserted;
 2289|      0|    newitem->prev = after_inserted->prev;
 2290|      0|    after_inserted->prev = newitem;
 2291|      0|    if (after_inserted == array->child)
 2292|      0|    {
 2293|      0|        array->child = newitem;
 2294|      0|    }
 2295|      0|    else
 2296|      0|    {
 2297|      0|        newitem->prev->next = newitem;
 2298|      0|    }
 2299|      0|    return true;
 2300|      0|}
 2301|       |
 2302|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
 2303|      0|{
 2304|      0|    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))
 2305|      0|    {
 2306|      0|        return false;
 2307|      0|    }
 2308|       |
 2309|      0|    if (replacement == item)
 2310|      0|    {
 2311|      0|        return true;
 2312|      0|    }
 2313|       |
 2314|      0|    replacement->next = item->next;
 2315|      0|    replacement->prev = item->prev;
 2316|       |
 2317|      0|    if (replacement->next != NULL)
 2318|      0|    {
 2319|      0|        replacement->next->prev = replacement;
 2320|      0|    }
 2321|      0|    if (parent->child == item)
 2322|      0|    {
 2323|      0|        if (parent->child->prev == parent->child)
 2324|      0|        {
 2325|      0|            replacement->prev = replacement;
 2326|      0|        }
 2327|      0|        parent->child = replacement;
 2328|      0|    }
 2329|      0|    else
 2330|      0|    {   /*
 2331|       |         * To find the last item in array quickly, we use prev in array.
 2332|       |         * We can't modify the last item's next pointer where this item was the parent's child
 2333|       |         */
 2334|      0|        if (replacement->prev != NULL)
 2335|      0|        {
 2336|      0|            replacement->prev->next = replacement;
 2337|      0|        }
 2338|      0|        if (replacement->next == NULL)
 2339|      0|        {
 2340|      0|            parent->child->prev = replacement;
 2341|      0|        }
 2342|      0|    }
 2343|       |
 2344|      0|    item->next = NULL;
 2345|      0|    item->prev = NULL;
 2346|      0|    cJSON_Delete(item);
 2347|       |
 2348|      0|    return true;
 2349|      0|}
 2350|       |
 2351|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
 2352|      0|{
 2353|      0|    if (which < 0)
 2354|      0|    {
 2355|      0|        return false;
 2356|      0|    }
 2357|       |
 2358|      0|    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
 2359|      0|}
 2360|       |
 2361|       |static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
 2362|      0|{
 2363|      0|    if ((replacement == NULL) || (string == NULL))
 2364|      0|    {
 2365|      0|        return false;
 2366|      0|    }
 2367|       |
 2368|       |    /* replace the name in the replacement */
 2369|      0|    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
 2370|      0|    {
 2371|      0|        cJSON_free(replacement->string);
 2372|      0|    }
 2373|      0|    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 2374|      0|    if (replacement->string == NULL)
 2375|      0|    {
 2376|      0|        return false;
 2377|      0|    }
 2378|       |
 2379|      0|    replacement->type &= ~cJSON_StringIsConst;
 2380|       |
 2381|      0|    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
 2382|      0|}
 2383|       |
 2384|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
 2385|      0|{
 2386|      0|    return replace_item_in_object(object, string, newitem, false);
 2387|      0|}
 2388|       |
 2389|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
 2390|      0|{
 2391|      0|    return replace_item_in_object(object, string, newitem, true);
 2392|      0|}
 2393|       |
 2394|       |/* Create basic types: */
 2395|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
 2396|      0|{
 2397|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2398|      0|    if(item)
 2399|      0|    {
 2400|      0|        item->type = cJSON_NULL;
 2401|      0|    }
 2402|       |
 2403|      0|    return item;
 2404|      0|}
 2405|       |
 2406|       |CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
 2407|      0|{
 2408|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2409|      0|    if(item)
 2410|      0|    {
 2411|      0|        item->type = cJSON_True;
 2412|      0|    }
 2413|       |
 2414|      0|    return item;
 2415|      0|}
 2416|       |
 2417|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
 2418|      0|{
 2419|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2420|      0|    if(item)
 2421|      0|    {
 2422|      0|        item->type = cJSON_False;
 2423|      0|    }
 2424|       |
 2425|      0|    return item;
 2426|      0|}
 2427|       |
 2428|       |CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
 2429|      0|{
 2430|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2431|      0|    if(item)
 2432|      0|    {
 2433|      0|        item->type = boolean ? cJSON_True : cJSON_False;
 2434|      0|    }
 2435|       |
 2436|      0|    return item;
 2437|      0|}
 2438|       |
 2439|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
 2440|      0|{
 2441|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2442|      0|    if(item)
 2443|      0|    {
 2444|      0|        item->type = cJSON_Number;
 2445|      0|        item->valuedouble = num;
 2446|       |
 2447|       |        /* use saturation in case of overflow */
 2448|      0|        if (num >= INT_MAX)
 2449|      0|        {
 2450|      0|            item->valueint = INT_MAX;
 2451|      0|        }
 2452|      0|        else if (num <= (double)INT_MIN)
 2453|      0|        {
 2454|      0|            item->valueint = INT_MIN;
 2455|      0|        }
 2456|      0|        else
 2457|      0|        {
 2458|      0|            item->valueint = (int)num;
 2459|      0|        }
 2460|      0|    }
 2461|       |
 2462|      0|    return item;
 2463|      0|}
 2464|       |
 2465|       |CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
 2466|      0|{
 2467|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2468|      0|    if(item)
 2469|      0|    {
 2470|      0|        item->type = cJSON_String;
 2471|      0|        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 2472|      0|        if(!item->valuestring)
 2473|      0|        {
 2474|      0|            cJSON_Delete(item);
 2475|      0|            return NULL;
 2476|      0|        }
 2477|      0|    }
 2478|       |
 2479|      0|    return item;
 2480|      0|}
 2481|       |
 2482|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
 2483|      0|{
 2484|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2485|      0|    if (item != NULL)
 2486|      0|    {
 2487|      0|        item->type = cJSON_String | cJSON_IsReference;
 2488|      0|        item->valuestring = (char*)cast_away_const(string);
 2489|      0|    }
 2490|       |
 2491|      0|    return item;
 2492|      0|}
 2493|       |
 2494|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
 2495|      0|{
 2496|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2497|      0|    if (item != NULL) {
 2498|      0|        item->type = cJSON_Object | cJSON_IsReference;
 2499|      0|        item->child = (cJSON*)cast_away_const(child);
 2500|      0|    }
 2501|       |
 2502|      0|    return item;
 2503|      0|}
 2504|       |
 2505|      0|CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
 2506|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2507|      0|    if (item != NULL) {
 2508|      0|        item->type = cJSON_Array | cJSON_IsReference;
 2509|      0|        item->child = (cJSON*)cast_away_const(child);
 2510|      0|    }
 2511|       |
 2512|      0|    return item;
 2513|      0|}
 2514|       |
 2515|       |CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
 2516|      0|{
 2517|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2518|      0|    if(item)
 2519|      0|    {
 2520|      0|        item->type = cJSON_Raw;
 2521|      0|        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
 2522|      0|        if(!item->valuestring)
 2523|      0|        {
 2524|      0|            cJSON_Delete(item);
 2525|      0|            return NULL;
 2526|      0|        }
 2527|      0|    }
 2528|       |
 2529|      0|    return item;
 2530|      0|}
 2531|       |
 2532|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
 2533|      0|{
 2534|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2535|      0|    if(item)
 2536|      0|    {
 2537|      0|        item->type=cJSON_Array;
 2538|      0|    }
 2539|       |
 2540|      0|    return item;
 2541|      0|}
 2542|       |
 2543|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
 2544|      0|{
 2545|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2546|      0|    if (item)
 2547|      0|    {
 2548|      0|        item->type = cJSON_Object;
 2549|      0|    }
 2550|       |
 2551|      0|    return item;
 2552|      0|}
 2553|       |
 2554|       |/* Create Arrays: */
 2555|       |CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
 2556|      0|{
 2557|      0|    size_t i = 0;
 2558|      0|    cJSON *n = NULL;
 2559|      0|    cJSON *p = NULL;
 2560|      0|    cJSON *a = NULL;
 2561|       |
 2562|      0|    if ((count < 0) || (numbers == NULL))
 2563|      0|    {
 2564|      0|        return NULL;
 2565|      0|    }
 2566|       |
 2567|      0|    a = cJSON_CreateArray();
 2568|       |
 2569|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2570|      0|    {
 2571|      0|        n = cJSON_CreateNumber(numbers[i]);
 2572|      0|        if (!n)
 2573|      0|        {
 2574|      0|            cJSON_Delete(a);
 2575|      0|            return NULL;
 2576|      0|        }
 2577|      0|        if(!i)
 2578|      0|        {
 2579|      0|            a->child = n;
 2580|      0|        }
 2581|      0|        else
 2582|      0|        {
 2583|      0|            suffix_object(p, n);
 2584|      0|        }
 2585|      0|        p = n;
 2586|      0|    }
 2587|       |
 2588|      0|    if (a && a->child) {
 2589|      0|        a->child->prev = n;
 2590|      0|    }
 2591|       |
 2592|      0|    return a;
 2593|      0|}
 2594|       |
 2595|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
 2596|      0|{
 2597|      0|    size_t i = 0;
 2598|      0|    cJSON *n = NULL;
 2599|      0|    cJSON *p = NULL;
 2600|      0|    cJSON *a = NULL;
 2601|       |
 2602|      0|    if ((count < 0) || (numbers == NULL))
 2603|      0|    {
 2604|      0|        return NULL;
 2605|      0|    }
 2606|       |
 2607|      0|    a = cJSON_CreateArray();
 2608|       |
 2609|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2610|      0|    {
 2611|      0|        n = cJSON_CreateNumber((double)numbers[i]);
 2612|      0|        if(!n)
 2613|      0|        {
 2614|      0|            cJSON_Delete(a);
 2615|      0|            return NULL;
 2616|      0|        }
 2617|      0|        if(!i)
 2618|      0|        {
 2619|      0|            a->child = n;
 2620|      0|        }
 2621|      0|        else
 2622|      0|        {
 2623|      0|            suffix_object(p, n);
 2624|      0|        }
 2625|      0|        p = n;
 2626|      0|    }
 2627|       |
 2628|      0|    if (a && a->child) {
 2629|      0|        a->child->prev = n;
 2630|      0|    }
 2631|       |
 2632|      0|    return a;
 2633|      0|}
 2634|       |
 2635|       |CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
 2636|      0|{
 2637|      0|    size_t i = 0;
 2638|      0|    cJSON *n = NULL;
 2639|      0|    cJSON *p = NULL;
 2640|      0|    cJSON *a = NULL;
 2641|       |
 2642|      0|    if ((count < 0) || (numbers == NULL))
 2643|      0|    {
 2644|      0|        return NULL;
 2645|      0|    }
 2646|       |
 2647|      0|    a = cJSON_CreateArray();
 2648|       |
 2649|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2650|      0|    {
 2651|      0|        n = cJSON_CreateNumber(numbers[i]);
 2652|      0|        if(!n)
 2653|      0|        {
 2654|      0|            cJSON_Delete(a);
 2655|      0|            return NULL;
 2656|      0|        }
 2657|      0|        if(!i)
 2658|      0|        {
 2659|      0|            a->child = n;
 2660|      0|        }
 2661|      0|        else
 2662|      0|        {
 2663|      0|            suffix_object(p, n);
 2664|      0|        }
 2665|      0|        p = n;
 2666|      0|    }
 2667|       |
 2668|      0|    if (a && a->child) {
 2669|      0|        a->child->prev = n;
 2670|      0|    }
 2671|       |
 2672|      0|    return a;
 2673|      0|}
 2674|       |
 2675|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
 2676|      0|{
 2677|      0|    size_t i = 0;
 2678|      0|    cJSON *n = NULL;
 2679|      0|    cJSON *p = NULL;
 2680|      0|    cJSON *a = NULL;
 2681|       |
 2682|      0|    if ((count < 0) || (strings == NULL))
 2683|      0|    {
 2684|      0|        return NULL;
 2685|      0|    }
 2686|       |
 2687|      0|    a = cJSON_CreateArray();
 2688|       |
 2689|      0|    for (i = 0; a && (i < (size_t)count); i++)
 2690|      0|    {
 2691|      0|        n = cJSON_CreateString(strings[i]);
 2692|      0|        if(!n)
 2693|      0|        {
 2694|      0|            cJSON_Delete(a);
 2695|      0|            return NULL;
 2696|      0|        }
 2697|      0|        if(!i)
 2698|      0|        {
 2699|      0|            a->child = n;
 2700|      0|        }
 2701|      0|        else
 2702|      0|        {
 2703|      0|            suffix_object(p,n);
 2704|      0|        }
 2705|      0|        p = n;
 2706|      0|    }
 2707|       |
 2708|      0|    if (a && a->child) {
 2709|      0|        a->child->prev = n;
 2710|      0|    }
 2711|       |
 2712|      0|    return a;
 2713|      0|}
 2714|       |
 2715|       |/* Duplication */
 2716|       |CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
 2717|      0|{
 2718|      0|    cJSON *newitem = NULL;
 2719|      0|    cJSON *child = NULL;
 2720|      0|    cJSON *next = NULL;
 2721|      0|    cJSON *newchild = NULL;
 2722|       |
 2723|       |    /* Bail on bad ptr */
 2724|      0|    if (!item)
 2725|      0|    {
 2726|      0|        goto fail;
 2727|      0|    }
 2728|       |    /* Create new item */
 2729|      0|    newitem = cJSON_New_Item(&global_hooks);
 2730|      0|    if (!newitem)
 2731|      0|    {
 2732|      0|        goto fail;
 2733|      0|    }
 2734|       |    /* Copy over all vars */
 2735|      0|    newitem->type = item->type & (~cJSON_IsReference);
 2736|      0|    newitem->valueint = item->valueint;
 2737|      0|    newitem->valuedouble = item->valuedouble;
 2738|      0|    if (item->valuestring)
 2739|      0|    {
 2740|      0|        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
 2741|      0|        if (!newitem->valuestring)
 2742|      0|        {
 2743|      0|            goto fail;
 2744|      0|        }
 2745|      0|    }
 2746|      0|    if (item->string)
 2747|      0|    {
 2748|      0|        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
 2749|      0|        if (!newitem->string)
 2750|      0|        {
 2751|      0|            goto fail;
 2752|      0|        }
 2753|      0|    }
 2754|       |    /* If non-recursive, then we're done! */
 2755|      0|    if (!recurse)
 2756|      0|    {
 2757|      0|        return newitem;
 2758|      0|    }
 2759|       |    /* Walk the ->next chain for the child. */
 2760|      0|    child = item->child;
 2761|      0|    while (child != NULL)
 2762|      0|    {
 2763|      0|        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
 2764|      0|        if (!newchild)
 2765|      0|        {
 2766|      0|            goto fail;
 2767|      0|        }
 2768|      0|        if (next != NULL)
 2769|      0|        {
 2770|       |            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
 2771|      0|            next->next = newchild;
 2772|      0|            newchild->prev = next;
 2773|      0|            next = newchild;
 2774|      0|        }
 2775|      0|        else
 2776|      0|        {
 2777|       |            /* Set newitem->child and move to it */
 2778|      0|            newitem->child = newchild;
 2779|      0|            next = newchild;
 2780|      0|        }
 2781|      0|        child = child->next;
 2782|      0|    }
 2783|      0|    if (newitem && newitem->child)
 2784|      0|    {
 2785|      0|        newitem->child->prev = newchild;
 2786|      0|    }
 2787|       |
 2788|      0|    return newitem;
 2789|       |
 2790|      0|fail:
 2791|      0|    if (newitem != NULL)
 2792|      0|    {
 2793|      0|        cJSON_Delete(newitem);
 2794|      0|    }
 2795|       |
 2796|      0|    return NULL;
 2797|      0|}
 2798|       |
 2799|       |static void skip_oneline_comment(char **input)
 2800|      0|{
 2801|      0|    *input += static_strlen("//");
 2802|       |
 2803|      0|    for (; (*input)[0] != '\0'; ++(*input))
 2804|      0|    {
 2805|      0|        if ((*input)[0] == '\n') {
 2806|      0|            *input += static_strlen("\n");
 2807|      0|            return;
 2808|      0|        }
 2809|      0|    }
 2810|      0|}
 2811|       |
 2812|       |static void skip_multiline_comment(char **input)
 2813|      0|{
 2814|      0|    *input += static_strlen("/*");
 2815|       |
 2816|      0|    for (; (*input)[0] != '\0'; ++(*input))
 2817|      0|    {
 2818|      0|        if (((*input)[0] == '*') && ((*input)[1] == '/'))
 2819|      0|        {
 2820|      0|            *input += static_strlen("*/");
 2821|      0|            return;
 2822|      0|        }
 2823|      0|    }
 2824|      0|}
 2825|       |
 2826|      0|static void minify_string(char **input, char **output) {
 2827|      0|    (*output)[0] = (*input)[0];
 2828|      0|    *input += static_strlen("\"");
 2829|      0|    *output += static_strlen("\"");
 2830|       |
 2831|       |
 2832|      0|    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
 2833|      0|        (*output)[0] = (*input)[0];
 2834|       |
 2835|      0|        if ((*input)[0] == '\"') {
 2836|      0|            (*output)[0] = '\"';
 2837|      0|            *input += static_strlen("\"");
 2838|      0|            *output += static_strlen("\"");
 2839|      0|            return;
 2840|      0|        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
 2841|      0|            (*output)[1] = (*input)[1];
 2842|      0|            *input += static_strlen("\"");
 2843|      0|            *output += static_strlen("\"");
 2844|      0|        }
 2845|      0|    }
 2846|      0|}
 2847|       |
 2848|       |CJSON_PUBLIC(void) cJSON_Minify(char *json)
 2849|      0|{
 2850|      0|    char *into = json;
 2851|       |
 2852|      0|    if (json == NULL)
 2853|      0|    {
 2854|      0|        return;
 2855|      0|    }
 2856|       |
 2857|      0|    while (json[0] != '\0')
 2858|      0|    {
 2859|      0|        switch (json[0])
 2860|      0|        {
 2861|      0|            case ' ':
 2862|      0|            case '\t':
 2863|      0|            case '\r':
 2864|      0|            case '\n':
 2865|      0|                json++;
 2866|      0|                break;
 2867|       |
 2868|      0|            case '/':
 2869|      0|                if (json[1] == '/')
 2870|      0|                {
 2871|      0|                    skip_oneline_comment(&json);
 2872|      0|                }
 2873|      0|                else if (json[1] == '*')
 2874|      0|                {
 2875|      0|                    skip_multiline_comment(&json);
 2876|      0|                } else {
 2877|      0|                    json++;
 2878|      0|                }
 2879|      0|                break;
 2880|       |
 2881|      0|            case '\"':
 2882|      0|                minify_string(&json, (char**)&into);
 2883|      0|                break;
 2884|       |
 2885|      0|            default:
 2886|      0|                into[0] = json[0];
 2887|      0|                json++;
 2888|      0|                into++;
 2889|      0|        }
 2890|      0|    }
 2891|       |
 2892|       |    /* and null-terminate. */
 2893|      0|    *into = '\0';
 2894|      0|}
 2895|       |
 2896|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
 2897|      0|{
 2898|      0|    if (item == NULL)
 2899|      0|    {
 2900|      0|        return false;
 2901|      0|    }
 2902|       |
 2903|      0|    return (item->type & 0xFF) == cJSON_Invalid;
 2904|      0|}
 2905|       |
 2906|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
 2907|      0|{
 2908|      0|    if (item == NULL)
 2909|      0|    {
 2910|      0|        return false;
 2911|      0|    }
 2912|       |
 2913|      0|    return (item->type & 0xFF) == cJSON_False;
 2914|      0|}
 2915|       |
 2916|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
 2917|      0|{
 2918|      0|    if (item == NULL)
 2919|      0|    {
 2920|      0|        return false;
 2921|      0|    }
 2922|       |
 2923|      0|    return (item->type & 0xff) == cJSON_True;
 2924|      0|}
 2925|       |
 2926|       |
 2927|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
 2928|      0|{
 2929|      0|    if (item == NULL)
 2930|      0|    {
 2931|      0|        return false;
 2932|      0|    }
 2933|       |
 2934|      0|    return (item->type & (cJSON_True | cJSON_False)) != 0;
 2935|      0|}
 2936|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
 2937|      0|{
 2938|      0|    if (item == NULL)
 2939|      0|    {
 2940|      0|        return false;
 2941|      0|    }
 2942|       |
 2943|      0|    return (item->type & 0xFF) == cJSON_NULL;
 2944|      0|}
 2945|       |
 2946|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
 2947|      0|{
 2948|      0|    if (item == NULL)
 2949|      0|    {
 2950|      0|        return false;
 2951|      0|    }
 2952|       |
 2953|      0|    return (item->type & 0xFF) == cJSON_Number;
 2954|      0|}
 2955|       |
 2956|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
 2957|      0|{
 2958|      0|    if (item == NULL)
 2959|      0|    {
 2960|      0|        return false;
 2961|      0|    }
 2962|       |
 2963|      0|    return (item->type & 0xFF) == cJSON_String;
 2964|      0|}
 2965|       |
 2966|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
 2967|      0|{
 2968|      0|    if (item == NULL)
 2969|      0|    {
 2970|      0|        return false;
 2971|      0|    }
 2972|       |
 2973|      0|    return (item->type & 0xFF) == cJSON_Array;
 2974|      0|}
 2975|       |
 2976|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
 2977|      0|{
 2978|      0|    if (item == NULL)
 2979|      0|    {
 2980|      0|        return false;
 2981|      0|    }
 2982|       |
 2983|      0|    return (item->type & 0xFF) == cJSON_Object;
 2984|      0|}
 2985|       |
 2986|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
 2987|      0|{
 2988|      0|    if (item == NULL)
 2989|      0|    {
 2990|      0|        return false;
 2991|      0|    }
 2992|       |
 2993|      0|    return (item->type & 0xFF) == cJSON_Raw;
 2994|      0|}
 2995|       |
 2996|       |CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
 2997|      0|{
 2998|      0|    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
 2999|      0|    {
 3000|      0|        return false;
 3001|      0|    }
 3002|       |
 3003|       |    /* check if type is valid */
 3004|      0|    switch (a->type & 0xFF)
 3005|      0|    {
 3006|      0|        case cJSON_False:
 3007|      0|        case cJSON_True:
 3008|      0|        case cJSON_NULL:
 3009|      0|        case cJSON_Number:
 3010|      0|        case cJSON_String:
 3011|      0|        case cJSON_Raw:
 3012|      0|        case cJSON_Array:
 3013|      0|        case cJSON_Object:
 3014|      0|            break;
 3015|       |
 3016|      0|        default:
 3017|      0|            return false;
 3018|      0|    }
 3019|       |
 3020|       |    /* identical objects are equal */
 3021|      0|    if (a == b)
 3022|      0|    {
 3023|      0|        return true;
 3024|      0|    }
 3025|       |
 3026|      0|    switch (a->type & 0xFF)
 3027|      0|    {
 3028|       |        /* in these cases and equal type is enough */
 3029|      0|        case cJSON_False:
 3030|      0|        case cJSON_True:
 3031|      0|        case cJSON_NULL:
 3032|      0|            return true;
 3033|       |
 3034|      0|        case cJSON_Number:
 3035|      0|            if (compare_double(a->valuedouble, b->valuedouble))
 3036|      0|            {
 3037|      0|                return true;
 3038|      0|            }
 3039|      0|            return false;
 3040|       |
 3041|      0|        case cJSON_String:
 3042|      0|        case cJSON_Raw:
 3043|      0|            if ((a->valuestring == NULL) || (b->valuestring == NULL))
 3044|      0|            {
 3045|      0|                return false;
 3046|      0|            }
 3047|      0|            if (strcmp(a->valuestring, b->valuestring) == 0)
 3048|      0|            {
 3049|      0|                return true;
 3050|      0|            }
 3051|       |
 3052|      0|            return false;
 3053|       |
 3054|      0|        case cJSON_Array:
 3055|      0|        {
 3056|      0|            cJSON *a_element = a->child;
 3057|      0|            cJSON *b_element = b->child;
 3058|       |
 3059|      0|            for (; (a_element != NULL) && (b_element != NULL);)
 3060|      0|            {
 3061|      0|                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 3062|      0|                {
 3063|      0|                    return false;
 3064|      0|                }
 3065|       |
 3066|      0|                a_element = a_element->next;
 3067|      0|                b_element = b_element->next;
 3068|      0|            }
 3069|       |
 3070|       |            /* one of the arrays is longer than the other */
 3071|      0|            if (a_element != b_element) {
 3072|      0|                return false;
 3073|      0|            }
 3074|       |
 3075|      0|            return true;
 3076|      0|        }
 3077|       |
 3078|      0|        case cJSON_Object:
 3079|      0|        {
 3080|      0|            cJSON *a_element = NULL;
 3081|      0|            cJSON *b_element = NULL;
 3082|      0|            cJSON_ArrayForEach(a_element, a)
 3083|      0|            {
 3084|       |                /* TODO This has O(n^2) runtime, which is horrible! */
 3085|      0|                b_element = get_object_item(b, a_element->string, case_sensitive);
 3086|      0|                if (b_element == NULL)
 3087|      0|                {
 3088|      0|                    return false;
 3089|      0|                }
 3090|       |
 3091|      0|                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 3092|      0|                {
 3093|      0|                    return false;
 3094|      0|                }
 3095|      0|            }
 3096|       |
 3097|       |            /* doing this twice, once on a and b to prevent true comparison if a subset of b
 3098|       |             * TODO: Do this the proper way, this is just a fix for now */
 3099|      0|            cJSON_ArrayForEach(b_element, b)
 3100|      0|            {
 3101|      0|                a_element = get_object_item(a, b_element->string, case_sensitive);
 3102|      0|                if (a_element == NULL)
 3103|      0|                {
 3104|      0|                    return false;
 3105|      0|                }
 3106|       |
 3107|      0|                if (!cJSON_Compare(b_element, a_element, case_sensitive))
 3108|      0|                {
 3109|      0|                    return false;
 3110|      0|                }
 3111|      0|            }
 3112|       |
 3113|      0|            return true;
 3114|      0|        }
 3115|       |
 3116|      0|        default:
 3117|      0|            return false;
 3118|      0|    }
 3119|      0|}
 3120|       |
 3121|       |CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
 3122|      0|{
 3123|      0|    return global_hooks.allocate(size);
 3124|      0|}
 3125|       |
 3126|       |CJSON_PUBLIC(void) cJSON_free(void *object)
 3127|      0|{
 3128|      0|    global_hooks.deallocate(object);
 3129|      0|}

/home/s22100141/Capston2/cJSON_ijon/fuzzing/afl.c:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |#include <stdio.h>
   24|       |#include <stdlib.h>
   25|       |#include <string.h>
   26|       |
   27|       |#include "../cJSON.h"
   28|       |
   29|       |static char *read_file(const char *filename)
   30|  1.26k|{
   31|  1.26k|    FILE *file = NULL;
   32|  1.26k|    long length = 0;
   33|  1.26k|    char *content = NULL;
   34|  1.26k|    size_t read_chars = 0;
   35|       |
   36|       |    /* open in read binary mode */
   37|  1.26k|    file = fopen(filename, "rb");
   38|  1.26k|    if (file == NULL)
   39|      0|    {
   40|      0|        goto cleanup;
   41|      0|    }
   42|       |
   43|       |    /* get the length */
   44|  1.26k|    if (fseek(file, 0, SEEK_END) != 0)
   45|      0|    {
   46|      0|        goto cleanup;
   47|      0|    }
   48|  1.26k|    length = ftell(file);
   49|  1.26k|    if (length < 0)
   50|      0|    {
   51|      0|        goto cleanup;
   52|      0|    }
   53|  1.26k|    if (fseek(file, 0, SEEK_SET) != 0)
   54|      0|    {
   55|      0|        goto cleanup;
   56|      0|    }
   57|       |
   58|       |    /* allocate content buffer */
   59|  1.26k|    content = (char*)malloc((size_t)length + sizeof(""));
   60|  1.26k|    if (content == NULL)
   61|      0|    {
   62|      0|        goto cleanup;
   63|      0|    }
   64|       |
   65|       |    /* read the file into memory */
   66|  1.26k|    read_chars = fread(content, sizeof(char), (size_t)length, file);
   67|  1.26k|    if ((long)read_chars != length)
   68|      0|    {
   69|      0|        free(content);
   70|      0|        content = NULL;
   71|      0|        goto cleanup;
   72|      0|    }
   73|  1.26k|    content[read_chars] = '\0';
   74|       |
   75|       |
   76|  1.26k|cleanup:
   77|  1.26k|    if (file != NULL)
   78|  1.26k|    {
   79|  1.26k|        fclose(file);
   80|  1.26k|    }
   81|       |
   82|  1.26k|    return content;
   83|  1.26k|}
   84|       |
   85|       |int main(int argc, char** argv)
   86|  1.26k|{
   87|  1.26k|    const char *filename = NULL;
   88|  1.26k|    cJSON *item = NULL;
   89|  1.26k|    char *json = NULL;
   90|  1.26k|    int status = EXIT_FAILURE;
   91|  1.26k|    char *printed_json = NULL;
   92|       |
   93|       |
   94|  1.26k|    if ((argc < 2) || (argc > 3))
   95|      0|    {
   96|      0|        printf("Usage:\n");
   97|      0|        printf("%s input_file [enable_printing]\n", argv[0]);
   98|      0|        printf("\t input_file: file containing the test data\n");
   99|      0|        printf("\t enable_printing: print after parsing, 'yes' or 'no', defaults to 'no'\n");
  100|      0|        goto cleanup;
  101|      0|    }
  102|       |
  103|  1.26k|    filename = argv[1];
  104|       |
  105|       |#if __AFL_HAVE_MANUAL_CONTROL
  106|       |    while (__AFL_LOOP(1000))
  107|       |    {
  108|       |#endif
  109|  1.26k|    status = EXIT_SUCCESS;
  110|       |
  111|  1.26k|    json = read_file(filename);
  112|  1.26k|    if ((json == NULL) || (json[0] == '\0') || (json[1] == '\0'))
  113|     10|    {
  114|     10|        status = EXIT_FAILURE;
  115|     10|        goto cleanup;
  116|     10|    }
  117|  1.25k|    item = cJSON_Parse(json + 2);
  118|  1.25k|    if (item == NULL)
  119|    672|    {
  120|    672|        goto cleanup;
  121|    672|    }
  122|       |
  123|    584|    char yes[5] = "yes";
  124|    584|    argv[2] = yes;
  125|    584|    argc = 3;
  126|       |
  127|    584|    if ((argc == 3) && (strncmp(argv[2], "yes", 3) == 0))
  128|    584|    {
  129|    584|        int do_format = 0;
  130|    584|        if (json[1] == 'f')
  131|    409|        {
  132|    409|            do_format = 1;
  133|    409|        }
  134|       |
  135|    584|        if (json[0] == 'b')
  136|    487|        {
  137|       |            /* buffered printing */
  138|    487|            printed_json = cJSON_PrintBuffered(item, 1, do_format);
  139|    487|        }
  140|     97|        else
  141|     97|        {
  142|       |            /* unbuffered printing */
  143|     97|            if (do_format)
  144|     30|            {
  145|     30|                printed_json = cJSON_Print(item);
  146|     30|            }
  147|     67|            else
  148|     67|            {
  149|     67|                printed_json = cJSON_PrintUnformatted(item);
  150|     67|            }
  151|     97|        }
  152|    584|        if (printed_json == NULL)
  153|      0|        {
  154|      0|            status = EXIT_FAILURE;
  155|      0|            goto cleanup;
  156|      0|        }
  157|    584|        printf("%s\n", printed_json);
  158|    584|    }
  159|       |
  160|  1.26k|cleanup:
  161|  1.26k|    if (item != NULL)
  162|    584|    {
  163|    584|        cJSON_Delete(item);
  164|    584|        item = NULL;
  165|    584|    }
  166|  1.26k|    if (json != NULL)
  167|  1.26k|    {
  168|  1.26k|        free(json);
  169|  1.26k|        json = NULL;
  170|  1.26k|    }
  171|  1.26k|    if (printed_json != NULL)
  172|    584|    {
  173|    584|        free(printed_json);
  174|    584|        printed_json = NULL;
  175|    584|    }
  176|       |#if __AFL_HAVE_MANUAL_CONTROL
  177|       |    }
  178|       |#endif
  179|       |//	printf("afl testing done");
  180|  1.26k|    return status;
  181|    584|}

